# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `flag_shih_tzu` gem.
# Please instead update this file by running `bin/tapioca gem flag_shih_tzu`.


module ActiveModel
  class << self
    def deprecator; end
    def eager_load!; end
    def gem_version; end
    def version; end
  end
end

module ActiveModel::Validations
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods

  def errors; end
  def invalid?(context = T.unsafe(nil)); end
  def read_attribute_for_validation(*_arg0); end
  def valid?(context = T.unsafe(nil)); end
  def validate(context = T.unsafe(nil)); end
  def validate!(context = T.unsafe(nil)); end
  def validates_with(*args, &block); end

  private

  def init_internals; end
  def initialize_dup(other); end
  def raise_validation_error; end
  def run_validations!; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _validators; end
    def _validators?; end
  end
end

module ActiveModel::Validations::HelperMethods
  def validates_absence_of(*attr_names); end
  def validates_acceptance_of(*attr_names); end
  def validates_comparison_of(*attr_names); end
  def validates_confirmation_of(*attr_names); end
  def validates_exclusion_of(*attr_names); end
  def validates_format_of(*attr_names); end
  def validates_inclusion_of(*attr_names); end
  def validates_length_of(*attr_names); end
  def validates_numericality_of(*attr_names); end
  def validates_presence_of(*attr_names); end
  def validates_presence_of_flags(*attr_names); end
  def validates_size_of(*attr_names); end

  private

  def _merge_attributes(attr_names); end
end

class ActiveModel::Validations::PresenceOfFlagsValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, value); end

  private

  def check_flag(record, attribute); end
end

module FlagShihTzu
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::FlagShihTzu::ClassMethods

  def all_flags(colmn = T.unsafe(nil)); end
  def as_flag_collection(colmn = T.unsafe(nil), *args); end
  def chained_flags_with_signature(colmn = T.unsafe(nil), *args); end
  def disable_flag(flag, colmn = T.unsafe(nil)); end
  def enable_flag(flag, colmn = T.unsafe(nil)); end
  def flag_disabled?(flag, colmn = T.unsafe(nil)); end
  def flag_enabled?(flag, colmn = T.unsafe(nil)); end
  def flags(colmn = T.unsafe(nil)); end
  def has_flag?(colmn = T.unsafe(nil)); end
  def select_all_flags(colmn = T.unsafe(nil)); end
  def selected_flags(colmn = T.unsafe(nil)); end
  def selected_flags=(chosen_flags); end
  def set_flags(value, colmn = T.unsafe(nil)); end
  def unselect_all_flags(colmn = T.unsafe(nil)); end
  def update_flag!(flag, value, update_instance = T.unsafe(nil)); end

  private

  def collect_flags(*args); end
  def determine_flag_colmn_for(flag); end
  def get_bit_for(flag, colmn); end

  class << self
    def included(base); end
  end

  module GeneratedClassMethods
    def flag_columns; end
    def flag_columns=(value); end
    def flag_columns?; end
    def flag_mapping; end
    def flag_mapping=(value); end
    def flag_mapping?; end
    def flag_options; end
    def flag_options=(value); end
    def flag_options?; end
  end

  module GeneratedInstanceMethods
    def flag_columns; end
    def flag_columns=(value); end
    def flag_columns?; end
    def flag_mapping; end
    def flag_mapping=(value); end
    def flag_mapping?; end
    def flag_options; end
    def flag_options=(value); end
    def flag_options?; end
  end
end

module FlagShihTzu::ClassMethods
  def chained_flags_condition(colmn = T.unsafe(nil), *args); end
  def chained_flags_with(column = T.unsafe(nil), *args); end
  def check_flag(flag, colmn); end
  def determine_flag_colmn_for(flag); end
  def flag_keys(colmn = T.unsafe(nil)); end
  def has_flags(*args); end
  def set_flag_sql(flag, value, colmn = T.unsafe(nil), custom_table_name = T.unsafe(nil)); end

  private

  def active_record_class?; end
  def chained_flags_values(colmn, *args); end
  def check_flag_column(colmn, custom_table_name = T.unsafe(nil)); end
  def flag_full_column_name(table, column); end
  def flag_full_column_name_for_assignment(table, column); end
  def flag_value_range_for_column(colmn); end
  def named_scope_method; end
  def parse_flag_options(*args); end
  def sql_condition_for_flag(flag, colmn, enabled = T.unsafe(nil), custom_table_name = T.unsafe(nil)); end
  def sql_in_for_flag(flag, colmn); end
  def sql_set_for_flag(flag, colmn, enabled = T.unsafe(nil), custom_table_name = T.unsafe(nil)); end
  def valid_flag_column_name?(colmn); end
  def valid_flag_key?(flag_key); end
  def valid_flag_name?(flag_name); end
end

FlagShihTzu::DEFAULT_COLUMN_NAME = T.let(T.unsafe(nil), String)
class FlagShihTzu::DuplicateFlagColumnException < ::Exception; end
class FlagShihTzu::IncorrectFlagColumnException < ::Exception; end
class FlagShihTzu::NoSuchFlagException < ::Exception; end
class FlagShihTzu::NoSuchFlagQueryModeException < ::Exception; end
FlagShihTzu::TRUE_VALUES = T.let(T.unsafe(nil), Array)
