# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `graphql` gem.
# Please instead update this file by running `bin/tapioca gem graphql`.


module GraphQL
  extend ::GraphQL::Autoload

  class << self
    def default_parser; end
    def default_parser=(_arg0); end
    def eager_load!; end
    def parse(graphql_string, trace: T.unsafe(nil), filename: T.unsafe(nil), max_tokens: T.unsafe(nil)); end
    def parse_file(filename); end
    def parse_with_racc(string, filename: T.unsafe(nil), trace: T.unsafe(nil)); end
    def reject_numbers_followed_by_names; end
    def reject_numbers_followed_by_names=(_arg0); end
    def scan(graphql_string); end
    def scan_with_ruby(graphql_string); end
  end
end

module GraphQL::Analysis
  private

  def analysis_errors(results); end
  def analyze_multiplex(multiplex, analyzers); end
  def analyze_query(query, analyzers, multiplex_analyzers: T.unsafe(nil)); end

  class << self
    def analysis_errors(results); end
    def analyze_multiplex(multiplex, analyzers); end
    def analyze_query(query, analyzers, multiplex_analyzers: T.unsafe(nil)); end
  end
end

GraphQL::Analysis::AST = GraphQL::Analysis

class GraphQL::Analysis::Analyzer
  def initialize(subject); end

  def analyze?; end
  def on_enter_abstract_node(node, parent, visitor); end
  def on_enter_argument(node, parent, visitor); end
  def on_enter_directive(node, parent, visitor); end
  def on_enter_document(node, parent, visitor); end
  def on_enter_enum(node, parent, visitor); end
  def on_enter_field(node, parent, visitor); end
  def on_enter_fragment_spread(node, parent, visitor); end
  def on_enter_inline_fragment(node, parent, visitor); end
  def on_enter_input_object(node, parent, visitor); end
  def on_enter_list_type(node, parent, visitor); end
  def on_enter_non_null_type(node, parent, visitor); end
  def on_enter_null_value(node, parent, visitor); end
  def on_enter_operation_definition(node, parent, visitor); end
  def on_enter_type_name(node, parent, visitor); end
  def on_enter_variable_definition(node, parent, visitor); end
  def on_enter_variable_identifier(node, parent, visitor); end
  def on_leave_abstract_node(node, parent, visitor); end
  def on_leave_argument(node, parent, visitor); end
  def on_leave_directive(node, parent, visitor); end
  def on_leave_document(node, parent, visitor); end
  def on_leave_enum(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end
  def on_leave_fragment_spread(node, parent, visitor); end
  def on_leave_inline_fragment(node, parent, visitor); end
  def on_leave_input_object(node, parent, visitor); end
  def on_leave_list_type(node, parent, visitor); end
  def on_leave_non_null_type(node, parent, visitor); end
  def on_leave_null_value(node, parent, visitor); end
  def on_leave_operation_definition(node, parent, visitor); end
  def on_leave_type_name(node, parent, visitor); end
  def on_leave_variable_definition(node, parent, visitor); end
  def on_leave_variable_identifier(node, parent, visitor); end
  def result; end
  def visit?; end

  protected

  def multiplex; end
  def query; end
  def subject; end

  class << self
    private

    def build_visitor_hooks(member_name); end
  end
end

class GraphQL::Analysis::FieldUsage < ::GraphQL::Analysis::Analyzer
  def initialize(query); end

  def on_leave_field(node, parent, visitor); end
  def result; end

  private

  def extract_deprecated_arguments(argument_values); end
  def extract_deprecated_enum_value(enum_type, value); end
end

class GraphQL::Analysis::MaxQueryComplexity < ::GraphQL::Analysis::QueryComplexity
  def result; end
end

class GraphQL::Analysis::MaxQueryDepth < ::GraphQL::Analysis::QueryDepth
  def result; end
end

class GraphQL::Analysis::QueryComplexity < ::GraphQL::Analysis::Analyzer
  def initialize(query); end

  def on_enter_field(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end
  def result; end

  private

  def field_complexity(scoped_type_complexity, max_complexity:, child_complexity: T.unsafe(nil)); end
  def max_possible_complexity; end
  def merged_max_complexity(query, inner_selections); end
  def merged_max_complexity_for_scopes(query, scopes); end
  def types_intersect?(query, a, b); end
end

class GraphQL::Analysis::QueryComplexity::ScopedTypeComplexity < ::Hash
  def initialize(parent_type, field_definition, query, response_path); end

  def field_definition; end
  def nodes; end
  def own_complexity(child_complexity); end
  def query; end
  def response_path; end
end

GraphQL::Analysis::QueryComplexity::ScopedTypeComplexity::DEFAULT_PROC = T.let(T.unsafe(nil), Proc)

class GraphQL::Analysis::QueryDepth < ::GraphQL::Analysis::Analyzer
  def initialize(query); end

  def on_enter_field(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end
  def result; end
end

class GraphQL::Analysis::Visitor < ::GraphQL::Language::StaticVisitor
  def initialize(query:, analyzers:); end

  def argument_definition; end
  def arguments_for(ast_node, field_definition); end
  def call_on_enter_argument(node, parent); end
  def call_on_enter_directive(node, parent); end
  def call_on_enter_field(node, parent); end
  def call_on_enter_fragment_definition(node, parent); end
  def call_on_enter_fragment_spread(node, parent); end
  def call_on_enter_inline_fragment(node, parent); end
  def call_on_enter_operation_definition(node, parent); end
  def call_on_leave_argument(node, parent); end
  def call_on_leave_directive(node, parent); end
  def call_on_leave_field(node, parent); end
  def call_on_leave_fragment_definition(node, parent); end
  def call_on_leave_fragment_spread(node, parent); end
  def call_on_leave_inline_fragment(node, parent); end
  def call_on_leave_operation_definition(node, parent); end
  def directive_definition; end
  def field_definition; end
  def object_types; end
  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_operation_definition(node, parent); end
  def parent_type_definition; end
  def previous_argument_definition; end
  def previous_field_definition; end
  def query; end
  def rescued_errors; end
  def response_path; end
  def skipping?; end
  def type_definition; end
  def visit; end
  def visiting_fragment_definition?; end

  private

  def enter_fragment_spread_inline(fragment_spread); end
  def leave_fragment_spread_inline(_fragment_spread); end
  def on_fragment_with_type(node); end
  def skip?(ast_node); end
end

class GraphQL::AnalysisError < ::GraphQL::ExecutionError; end

module GraphQL::Autoload
  def autoload(const_name, path); end
  def eager_load!; end

  private

  def eager_loading?; end
end

class GraphQL::Backtrace
  include ::Enumerable
  extend ::Forwardable

  def initialize(context, value: T.unsafe(nil)); end

  def [](*args, **_arg1, &block); end
  def each(*args, **_arg1, &block); end
  def inspect; end
  def to_a; end
  def to_s; end

  class << self
    def use(schema_defn); end
  end
end

class GraphQL::Backtrace::Table
  def initialize(context, value:); end

  def to_backtrace; end
  def to_table; end

  private

  def inspect_result(obj); end
  def inspect_truncated(obj); end
  def render_table(rows); end
  def rows; end
  def value_at(runtime, path); end
end

GraphQL::Backtrace::Table::HEADERS = T.let(T.unsafe(nil), Array)
GraphQL::Backtrace::Table::MAX_COL_WIDTH = T.let(T.unsafe(nil), Integer)
GraphQL::Backtrace::Table::MIN_COL_WIDTH = T.let(T.unsafe(nil), Integer)

class GraphQL::Backtrace::TracedError < ::GraphQL::Error
  def initialize(err, current_ctx); end

  def context; end
  def graphql_backtrace; end
end

GraphQL::Backtrace::TracedError::CAUSE_BACKTRACE_PREVIEW_LENGTH = T.let(T.unsafe(nil), Integer)
GraphQL::Backtrace::TracedError::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)
class GraphQL::CoercionError < ::GraphQL::ExecutionError; end

module GraphQL::Current
  class << self
    def dataloader_source; end
    def dataloader_source_class; end
    def field; end
    def operation_name; end
  end
end

class GraphQL::Dataloader
  def initialize(nonblocking: T.unsafe(nil), fiber_limit: T.unsafe(nil)); end

  def append_job(&job); end
  def cleanup_fiber; end
  def clear_cache; end
  def fiber_limit; end
  def get_fiber_variables; end
  def merge_records(records, index_by: T.unsafe(nil)); end
  def nonblocking?; end
  def run; end
  def run_fiber(f); end
  def run_isolated; end
  def set_fiber_variables(vars); end
  def spawn_fiber; end
  def with(source_class, *batch_args, **batch_kwargs); end
  def yield(source = T.unsafe(nil)); end

  private

  def calculate_fiber_limit; end
  def join_queues(prev_queue, new_queue); end
  def spawn_job_fiber(trace); end
  def spawn_source_fiber(trace); end

  class << self
    def default_fiber_limit; end
    def default_fiber_limit=(_arg0); end
    def default_nonblocking; end
    def default_nonblocking=(_arg0); end
    def use(schema, nonblocking: T.unsafe(nil), fiber_limit: T.unsafe(nil)); end
    def with_dataloading(&block); end
  end
end

class GraphQL::Dataloader::ActiveRecordAssociationSource < ::GraphQL::Dataloader::Source
  def initialize(association, scope = T.unsafe(nil)); end

  def fetch(records); end
  def load(record); end
end

GraphQL::Dataloader::ActiveRecordAssociationSource::RECORD_SOURCE_CLASS = GraphQL::Dataloader::ActiveRecordSource

class GraphQL::Dataloader::ActiveRecordSource < ::GraphQL::Dataloader::Source
  def initialize(model_class, find_by: T.unsafe(nil)); end

  def fetch(record_ids); end
  def load(requested_key); end
end

class GraphQL::Dataloader::AsyncDataloader < ::GraphQL::Dataloader
  def run; end
  def yield(source = T.unsafe(nil)); end

  private

  def spawn_source_task(parent_task, condition, trace); end
end

class GraphQL::Dataloader::NullDataloader < ::GraphQL::Dataloader
  def append_job; end
  def run; end
  def run_isolated; end
  def yield(_source); end
end

class GraphQL::Dataloader::Request
  def initialize(source, key); end

  def load; end
  def load_with_deprecation_warning; end
end

class GraphQL::Dataloader::RequestAll < ::GraphQL::Dataloader::Request
  def initialize(source, keys); end

  def load; end
end

class GraphQL::Dataloader::Source
  def clear_cache; end
  def dataloader; end
  def fetch(keys); end
  def load(value); end
  def load_all(values); end
  def merge(new_results); end
  def pending; end
  def pending?; end
  def request(value); end
  def request_all(values); end
  def result_key_for(value); end
  def results; end
  def run_pending_keys; end
  def setup(dataloader); end
  def sync(pending_result_keys); end

  private

  def result_for(key); end

  class << self
    def batch_key_for(*batch_args, **batch_kwargs); end
  end
end

GraphQL::Dataloader::Source::MAX_ITERATIONS = T.let(T.unsafe(nil), Integer)

class GraphQL::DateEncodingError < ::GraphQL::RuntimeTypeError
  def initialize(value); end

  def date_value; end
end

module GraphQL::Dig
  def dig(own_key, *rest_keys); end
end

class GraphQL::DurationEncodingError < ::GraphQL::RuntimeTypeError
  def initialize(value); end

  def duration_value; end
end

module GraphQL::EmptyObjects; end
GraphQL::EmptyObjects::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
GraphQL::EmptyObjects::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
class GraphQL::Error < ::StandardError; end
module GraphQL::Execution; end

module GraphQL::Execution::DirectiveChecks
  private

  def include?(directive_ast_nodes, query); end

  class << self
    def include?(directive_ast_nodes, query); end
  end
end

GraphQL::Execution::DirectiveChecks::INCLUDE = T.let(T.unsafe(nil), String)
GraphQL::Execution::DirectiveChecks::SKIP = T.let(T.unsafe(nil), String)

class GraphQL::Execution::Errors
  class << self
    def find_handler_for(schema, error_class); end
    def register_rescue_from(error_class, error_handlers, error_handler); end
  end
end

class GraphQL::Execution::Interpreter
  class << self
    def run_all(schema, query_options, context: T.unsafe(nil), max_complexity: T.unsafe(nil)); end
  end
end

class GraphQL::Execution::Interpreter::ArgumentValue
  def initialize(definition:, value:, original_value:, default_used:); end

  def default_used?; end
  def definition; end
  def original_value; end
  def value; end
end

class GraphQL::Execution::Interpreter::Arguments
  include ::GraphQL::Dig
  extend ::Forwardable

  def initialize(argument_values:, keyword_arguments: T.unsafe(nil)); end

  def [](*args, **_arg1, &block); end
  def argument_values; end
  def each(*args, **_arg1, &block); end
  def each_value(*args, **_arg1, &block); end
  def empty?; end
  def fetch(*args, **_arg1, &block); end
  def inspect; end
  def key?(*args, **_arg1, &block); end
  def keys(*args, **_arg1, &block); end
  def keyword_arguments; end
  def merge_extras(extra_args); end
  def size(*args, **_arg1, &block); end
  def to_h(*args, **_arg1, &block); end
  def values(*args, **_arg1, &block); end
end

GraphQL::Execution::Interpreter::Arguments::EMPTY = T.let(T.unsafe(nil), GraphQL::Execution::Interpreter::Arguments)
GraphQL::Execution::Interpreter::Arguments::NO_ARGS = T.let(T.unsafe(nil), Hash)

class GraphQL::Execution::Interpreter::ArgumentsCache
  def initialize(query); end

  def dataload_for(ast_node, argument_owner, parent_object, &block); end
  def fetch(ast_node, argument_owner, parent_object); end

  class << self
    def prepare_args_hash(query, ast_arg_or_hash_or_value); end
  end
end

GraphQL::Execution::Interpreter::ArgumentsCache::NO_ARGUMENTS = T.let(T.unsafe(nil), Hash)
GraphQL::Execution::Interpreter::ArgumentsCache::NO_VALUE_GIVEN = T.let(T.unsafe(nil), Object)

class GraphQL::Execution::Interpreter::ExecutionErrors
  def initialize(ctx, ast_node, path); end

  def add(err_or_msg); end
end

class GraphQL::Execution::Interpreter::ListResultFailedError < ::GraphQL::Error
  def initialize(value:, path:, field:); end
end

class GraphQL::Execution::Interpreter::RawValue
  def initialize(obj = T.unsafe(nil)); end

  def resolve; end
end

module GraphQL::Execution::Interpreter::Resolve
  class << self
    def resolve(results, dataloader); end
    def resolve_all(results, dataloader); end
    def resolve_each_depth(lazies_at_depth, dataloader); end
  end
end

class GraphQL::Execution::Interpreter::Runtime
  def initialize(query:, lazies_at_depth:); end

  def after_lazy(lazy_obj, field:, owner_object:, arguments:, ast_node:, result:, result_name:, runtime_state:, eager: T.unsafe(nil), trace: T.unsafe(nil), &block); end
  def arguments(graphql_object, arg_owner, ast_node); end
  def call_method_on_directives(method_name, object, directives, &block); end
  def context; end
  def continue_field(value, owner_type, field, current_type, ast_node, next_selections, is_non_null, owner_object, arguments, result_name, selection_result, was_scoped, runtime_state); end
  def continue_value(value, field, is_non_null, ast_node, result_name, selection_result); end
  def current_path; end
  def delete_all_interpreter_context; end
  def directives_include?(node, graphql_object, parent_type); end
  def each_gathered_selections(response_hash); end
  def evaluate_selection(result_name, field_ast_nodes_or_ast_node, selections_result); end
  def evaluate_selection_with_args(arguments, field_defn, ast_node, field_ast_nodes, object, result_name, selection_result, runtime_state); end
  def evaluate_selection_with_resolved_keyword_args(kwarg_arguments, resolved_arguments, field_defn, ast_node, field_ast_nodes, object, result_name, selection_result, runtime_state); end
  def evaluate_selections(gathered_selections, selections_result, target_result, runtime_state); end
  def final_result; end
  def gather_selections(owner_object, owner_type, selections, selections_to_run = T.unsafe(nil), selections_by_name = T.unsafe(nil)); end
  def get_current_runtime_state; end
  def inspect; end
  def lazy?(object); end
  def minimal_after_lazy(value, &block); end
  def query; end
  def resolve_list_item(inner_value, inner_type, inner_type_non_null, ast_node, field, owner_object, arguments, this_idx, response_list, owner_type, was_scoped, runtime_state); end
  def resolve_type(type, value); end
  def run_directive(method_name, object, directives, idx, &block); end
  def run_eager; end
  def schema; end
  def set_graphql_dead(selection_result); end
  def set_result(selection_result, result_name, value, is_child_result, is_non_null); end
end

class GraphQL::Execution::Interpreter::Runtime::CurrentState
  def initialize; end

  def current_arguments; end
  def current_arguments=(_arg0); end
  def current_field; end
  def current_field=(_arg0); end
  def current_object; end
  def current_result; end
  def current_result=(_arg0); end
  def current_result_name; end
  def current_result_name=(_arg0); end
  def was_authorized_by_scope_items; end
  def was_authorized_by_scope_items=(_arg0); end
end

module GraphQL::Execution::Interpreter::Runtime::GraphQLResult
  def initialize(result_name, result_type, application_value, parent_result, is_non_null_in_parent, selections, is_eager, ast_node, graphql_arguments, graphql_field); end

  def ast_node; end
  def build_path(path_array); end
  def graphql_application_value; end
  def graphql_arguments; end
  def graphql_dead; end
  def graphql_dead=(_arg0); end
  def graphql_field; end
  def graphql_is_eager; end
  def graphql_is_non_null_in_parent; end
  def graphql_parent; end
  def graphql_result_data; end
  def graphql_result_data=(_arg0); end
  def graphql_result_name; end
  def graphql_result_type; end
  def graphql_selections; end
  def path; end
end

class GraphQL::Execution::Interpreter::Runtime::GraphQLResultArray
  include ::GraphQL::Execution::Interpreter::Runtime::GraphQLResult

  def initialize(_result_name, _result_type, _application_value, _parent_result, _is_non_null_in_parent, _selections, _is_eager, _ast_node, _graphql_arguments, graphql_field); end

  def [](idx); end
  def graphql_skip_at(index); end
  def set_child_result(idx, value); end
  def set_leaf(idx, value); end
  def values; end
end

class GraphQL::Execution::Interpreter::Runtime::GraphQLResultHash
  include ::GraphQL::Execution::Interpreter::Runtime::GraphQLResult

  def initialize(_result_name, _result_type, _application_value, _parent_result, _is_non_null_in_parent, _selections, _is_eager, _ast_node, _graphql_arguments, graphql_field); end

  def [](k); end
  def delete(key); end
  def each; end
  def graphql_merged_into; end
  def graphql_merged_into=(_arg0); end
  def key?(k); end
  def merge_into(into_result); end
  def set_child_result(key, value); end
  def set_leaf(key, value); end
  def values; end
end

GraphQL::Execution::Interpreter::Runtime::HALT = T.let(T.unsafe(nil), Object)
GraphQL::Execution::Interpreter::Runtime::NO_ARGS = T.let(T.unsafe(nil), Hash)

class GraphQL::Execution::Lazy
  def initialize(field: T.unsafe(nil), &get_value_func); end

  def field; end
  def then; end
  def value; end

  class << self
    def all(lazies); end
  end
end

class GraphQL::Execution::Lazy::LazyMethodMap
  def initialize(use_concurrent: T.unsafe(nil)); end

  def each; end
  def get(value); end
  def set(lazy_class, lazy_value_method); end

  protected

  def storage; end

  private

  def find_superclass_method(value_class); end
  def initialize_copy(other); end
end

class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  extend ::Forwardable

  def initialize; end

  def []=(key, value); end
  def compute_if_absent(key); end
  def each_pair(*args, **_arg1, &block); end
  def size(*args, **_arg1, &block); end

  protected

  def copy_storage; end

  private

  def initialize_copy(other); end
end

GraphQL::Execution::Lazy::NullResult = T.let(T.unsafe(nil), GraphQL::Execution::Lazy)

class GraphQL::Execution::Lookahead
  def initialize(query:, ast_nodes:, field: T.unsafe(nil), root_type: T.unsafe(nil), owner_type: T.unsafe(nil)); end

  def alias_selection(alias_name, selected_type: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def arguments; end
  def ast_nodes; end
  def field; end
  def inspect; end
  def name; end
  def owner_type; end
  def selected?; end
  def selection(field_name, selected_type: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def selections(arguments: T.unsafe(nil)); end
  def selects?(field_name, selected_type: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def selects_alias?(alias_name, arguments: T.unsafe(nil)); end

  private

  def alias_selections; end
  def arguments_match?(arguments, field_defn, field_node); end
  def find_selected_nodes(node, field_name, field_defn, arguments:, matches:, alias_name: T.unsafe(nil)); end
  def find_selections(subselections_by_type, selections_on_type, selected_type, ast_selections, arguments); end
  def lookahead_for_selection(field_defn, selected_type, arguments, alias_name = T.unsafe(nil)); end
  def lookup_alias_node(nodes, name); end
  def lookup_fragment(ast_selection); end
  def skipped_by_directive?(ast_selection); end
  def unwrap_fragments(node); end
end

GraphQL::Execution::Lookahead::NULL_LOOKAHEAD = T.let(T.unsafe(nil), GraphQL::Execution::Lookahead::NullLookahead)

class GraphQL::Execution::Lookahead::NullLookahead < ::GraphQL::Execution::Lookahead
  def initialize; end

  def inspect; end
  def selected?; end
  def selection(*_arg0); end
  def selections(*_arg0); end
  def selects?(*_arg0); end
end

class GraphQL::Execution::Multiplex
  include ::GraphQL::Tracing::Traceable

  def initialize(schema:, queries:, context:, max_complexity:); end

  def context; end
  def current_trace; end
  def dataloader; end
  def max_complexity; end
  def queries; end
  def schema; end
end

GraphQL::Execution::SKIP = T.let(T.unsafe(nil), GraphQL::Execution::Skip)
class GraphQL::Execution::Skip < ::GraphQL::Error; end

class GraphQL::ExecutionError < ::GraphQL::Error
  def initialize(message, ast_node: T.unsafe(nil), options: T.unsafe(nil), extensions: T.unsafe(nil)); end

  def ast_node; end
  def ast_node=(_arg0); end
  def extensions; end
  def extensions=(_arg0); end
  def options; end
  def options=(_arg0); end
  def path; end
  def path=(_arg0); end
  def to_h; end
end

class GraphQL::IntegerDecodingError < ::GraphQL::RuntimeTypeError
  def initialize(value); end

  def integer_value; end
end

class GraphQL::IntegerEncodingError < ::GraphQL::RuntimeTypeError
  def initialize(value, context:); end

  def field; end
  def integer_value; end
  def path; end
end

module GraphQL::Introspection
  class << self
    def query(include_deprecated_args: T.unsafe(nil), include_schema_description: T.unsafe(nil), include_is_repeatable: T.unsafe(nil), include_specified_by_url: T.unsafe(nil), include_is_one_of: T.unsafe(nil)); end
  end
end

class GraphQL::Introspection::BaseObject < ::GraphQL::Schema::Object
  extend ::GraphQL::Schema::Member::HasInterfaces::ClassConfigured::InheritedInterfaces

  class << self
    def field(*args, **kwargs, &block); end
  end
end

class GraphQL::Introspection::DirectiveLocationEnum < ::GraphQL::Schema::Enum; end
class GraphQL::Introspection::DirectiveLocationEnum::UnresolvedValueError < ::GraphQL::Schema::Enum::UnresolvedValueError; end

class GraphQL::Introspection::DirectiveType < ::GraphQL::Introspection::BaseObject
  def args(include_deprecated:); end
end

class GraphQL::Introspection::DynamicFields < ::GraphQL::Introspection::BaseObject
  def __typename; end
end

class GraphQL::Introspection::EntryPoints < ::GraphQL::Introspection::BaseObject
  def __schema; end
  def __type(name:); end
end

class GraphQL::Introspection::EnumValueType < ::GraphQL::Introspection::BaseObject
  def is_deprecated; end
  def name; end
end

class GraphQL::Introspection::FieldType < ::GraphQL::Introspection::BaseObject
  def args(include_deprecated:); end
  def is_deprecated; end
end

GraphQL::Introspection::INTROSPECTION_QUERY = T.let(T.unsafe(nil), String)

class GraphQL::Introspection::InputValueType < ::GraphQL::Introspection::BaseObject
  def default_value; end
  def is_deprecated; end

  private

  def serialize_default_value(value, type); end
end

class GraphQL::Introspection::SchemaType < ::GraphQL::Introspection::BaseObject
  def directives; end
  def mutation_type; end
  def query_type; end
  def schema_description; end
  def subscription_type; end
  def types; end
end

class GraphQL::Introspection::TypeKindEnum < ::GraphQL::Schema::Enum
  class << self
    def enum; end
    def input_object; end
    def interface; end
    def list; end
    def non_null; end
    def object; end
    def scalar; end
    def union; end
  end
end

class GraphQL::Introspection::TypeKindEnum::UnresolvedValueError < ::GraphQL::Schema::Enum::UnresolvedValueError; end

class GraphQL::Introspection::TypeType < ::GraphQL::Introspection::BaseObject
  def enum_values(include_deprecated:); end
  def fields(include_deprecated:); end
  def input_fields(include_deprecated:); end
  def interfaces; end
  def is_one_of; end
  def kind; end
  def of_type; end
  def possible_types; end
  def specified_by_url; end
end

class GraphQL::InvalidNameError < ::GraphQL::ExecutionError
  def initialize(name, valid_regex); end

  def name; end
  def valid_regex; end
end

class GraphQL::InvalidNullError < ::GraphQL::RuntimeTypeError
  def initialize(parent_type, field, value); end

  def field; end
  def parent_error?; end
  def parent_type; end
  def to_h; end
  def value; end

  class << self
    def inspect; end
    def parent_class; end
    def parent_class=(_arg0); end
    def subclass_for(parent_class); end
  end
end

class GraphQL::InvariantError < ::GraphQL::Error
  def initialize(message); end
end

module GraphQL::Language
  class << self
    def add_space_between_numbers_and_names(query_str); end
    def escape_single_quoted_newlines(query_str); end
    def serialize(value); end
  end
end

module GraphQL::Language::BlockString
  class << self
    def break_line(line, length); end
    def contains_only_whitespace?(line); end
    def print(str, indent: T.unsafe(nil)); end
    def trim_whitespace(str); end
  end
end

class GraphQL::Language::Cache
  def initialize(path); end

  def fetch(filename); end
end

GraphQL::Language::Cache::DIGEST = T.let(T.unsafe(nil), Digest::SHA256)

module GraphQL::Language::Comment
  class << self
    def print(str, indent: T.unsafe(nil)); end
  end
end

module GraphQL::Language::DefinitionSlice
  extend ::GraphQL::Language::DefinitionSlice

  def slice(document, name); end
end

class GraphQL::Language::DefinitionSlice::DependencyVisitor < ::GraphQL::Language::StaticVisitor
  def initialize(doc, definitions, names); end

  def on_fragment_spread(node, parent); end

  class << self
    def find_definition_dependencies(definitions, name, names); end
  end
end

class GraphQL::Language::DocumentFromSchemaDefinition
  def initialize(schema, context: T.unsafe(nil), include_introspection_types: T.unsafe(nil), include_built_in_directives: T.unsafe(nil), include_built_in_scalars: T.unsafe(nil), always_include_schema: T.unsafe(nil)); end

  def build_argument_node(argument); end
  def build_argument_nodes(arguments); end
  def build_default_value(default_value, type); end
  def build_definition_nodes; end
  def build_directive_location_node(location); end
  def build_directive_location_nodes(locations); end
  def build_directive_node(directive); end
  def build_directive_nodes(directives); end
  def build_enum_type_node(enum_type); end
  def build_enum_value_node(enum_value); end
  def build_field_node(field); end
  def build_field_nodes(fields); end
  def build_input_object_node(input_object); end
  def build_interface_type_node(interface_type); end
  def build_object_type_node(object_type); end
  def build_scalar_type_node(scalar_type); end
  def build_schema_node; end
  def build_type_definition_node(type); end
  def build_type_definition_nodes(types); end
  def build_type_name_node(type); end
  def build_union_type_node(union_type); end
  def document; end

  private

  def always_include_schema; end
  def definition_directives(member, directives_method); end
  def directives(member); end
  def include_built_in_directives; end
  def include_built_in_scalars; end
  def include_introspection_types; end
  def include_schema_node?; end
  def schema; end
  def schema_respects_root_name_conventions?(schema); end
end

module GraphQL::Language::Generation
  extend ::GraphQL::Language::Generation

  def generate(node, indent: T.unsafe(nil), printer: T.unsafe(nil)); end
end

GraphQL::Language::INVALID_NUMBER_FOLLOWED_BY_NAME_REGEXP = T.let(T.unsafe(nil), Regexp)

class GraphQL::Language::Lexer
  def initialize(graphql_str, filename: T.unsafe(nil), max_tokens: T.unsafe(nil)); end

  def _hash(key); end
  def advance; end
  def column_number; end
  def debug_token_value(token_name); end
  def eos?; end
  def line_number; end
  def pos; end
  def raise_parse_error(message, line = T.unsafe(nil), col = T.unsafe(nil)); end
  def string_value; end
  def token_value; end
  def tokens_count; end

  class << self
    def replace_escaped_characters_in_place(raw_string); end
    def tokenize(string); end
  end
end

GraphQL::Language::Lexer::BLOCK_QUOTE = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::BLOCK_STRING_REGEXP = T.let(T.unsafe(nil), Regexp)
module GraphQL::Language::Lexer::ByteFor; end
GraphQL::Language::Lexer::ByteFor::ELLIPSIS = T.let(T.unsafe(nil), Integer)
GraphQL::Language::Lexer::ByteFor::IDENTIFIER = T.let(T.unsafe(nil), Integer)
GraphQL::Language::Lexer::ByteFor::NAME = T.let(T.unsafe(nil), Integer)
GraphQL::Language::Lexer::ByteFor::NUMBER = T.let(T.unsafe(nil), Integer)
GraphQL::Language::Lexer::ByteFor::PUNCTUATION = T.let(T.unsafe(nil), Integer)
GraphQL::Language::Lexer::ByteFor::STRING = T.let(T.unsafe(nil), Integer)
GraphQL::Language::Lexer::ESCAPED = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::ESCAPED_QUOTE = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::ESCAPES = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::ESCAPES_REPLACE = T.let(T.unsafe(nil), Hash)
GraphQL::Language::Lexer::FIRST_BYTES = T.let(T.unsafe(nil), Array)
GraphQL::Language::Lexer::FLOAT_DECIMAL_REGEXP = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::FLOAT_EXP_REGEXP = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::FOUR_DIGIT_UNICODE = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::IDENTIFIER_REGEXP = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::IGNORE_REGEXP = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::INT_REGEXP = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::KEYWORDS = T.let(T.unsafe(nil), Array)
GraphQL::Language::Lexer::KEYWORD_BY_TWO_BYTES = T.let(T.unsafe(nil), Array)
GraphQL::Language::Lexer::KEYWORD_REGEXP = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::NUMERIC_REGEXP = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::N_DIGIT_UNICODE = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::PUNCTUATION_NAME_FOR_BYTE = T.let(T.unsafe(nil), Array)
module GraphQL::Language::Lexer::Punctuation; end
GraphQL::Language::Lexer::Punctuation::AMP = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::BANG = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::COLON = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::DIR_SIGN = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::EQUALS = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::LBRACKET = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::LCURLY = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::LPAREN = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::PIPE = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::RBRACKET = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::RCURLY = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::RPAREN = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::Punctuation::VAR_SIGN = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::QUOTE = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::QUOTED_STRING_REGEXP = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::STRING_CHAR = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::STRING_ESCAPE = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::UNICODE_DIGIT = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::UNICODE_ESCAPE = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::UTF_8 = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::VALID_STRING = T.let(T.unsafe(nil), Regexp)
module GraphQL::Language::Nodes; end

class GraphQL::Language::Nodes::AbstractNode
  def ==(other); end
  def children; end
  def children_method_name; end
  def col; end
  def definition_line; end
  def delete_child(previous_child); end
  def filename; end
  def line; end
  def merge(new_options); end
  def position; end
  def replace_child(previous_child, new_child); end
  def scalars; end
  def to_query_string(printer: T.unsafe(nil)); end

  protected

  def merge!(new_options); end

  private

  def initialize_copy(other); end

  class << self
    def children_of_type; end
    def inherited(child_class); end

    private

    def children_methods(children_of_type); end
    def generate_initialize; end
    def scalar_methods(*method_names); end
  end
end

module GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def initialize(definition_line: T.unsafe(nil), **_rest); end

  def definition_line; end
  def marshal_dump; end
  def marshal_load(values); end
end

GraphQL::Language::Nodes::AbstractNode::NO_CHILDREN = T.let(T.unsafe(nil), Array)

class GraphQL::Language::Nodes::Argument < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), value: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def marshal_dump; end
  def marshal_load(values); end
  def name; end
  def scalars; end
  def value; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, value, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::Directive < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), arguments: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def arguments; end
  def children; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_argument(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, arguments, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::DirectiveDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), repeatable: T.unsafe(nil), description: T.unsafe(nil), arguments: T.unsafe(nil), locations: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def arguments; end
  def children; end
  def description; end
  def locations; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_argument(**node_opts); end
  def merge_location(**node_opts); end
  def name; end
  def repeatable; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, repeatable, description, arguments, locations, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::DirectiveLocation < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::Document < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(definitions: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def definitions; end
  def marshal_dump; end
  def marshal_load(values); end
  def slice_definition(name); end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, definitions, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::Enum < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::EnumTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def comment; end
  def description; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_value(**node_opts); end
  def name; end
  def scalars; end
  def values; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, description, directives, values, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::EnumTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_value(**node_opts); end
  def name; end
  def scalars; end
  def values; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, directives, values, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::EnumValueDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def comment; end
  def description; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, description, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::Field < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), arguments: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil), field_alias: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def alias; end
  def arguments; end
  def children; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_argument(**node_opts); end
  def merge_directive(**node_opts); end
  def merge_selection(**node_opts); end
  def name; end
  def scalars; end
  def selections; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, field_alias, name, arguments, directives, selections); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::FieldDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), type: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), arguments: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def arguments; end
  def children; end
  def comment; end
  def description; end
  def directives; end
  def fields; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge(new_options); end
  def merge_argument(**node_opts); end
  def merge_directive(**node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, type, description, arguments, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::FragmentDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), type: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil), filename: T.unsafe(nil), pos: T.unsafe(nil), source: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil)); end

  def children; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_selection(**node_opts); end
  def name; end
  def scalars; end
  def selections; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, type, directives, selections); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::FragmentSpread < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::InlineFragment < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(type: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_selection(**node_opts); end
  def scalars; end
  def selections; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, type, directives, selections, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::InputObject < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(arguments: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def arguments; end
  def children; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_argument(**node_opts); end
  def to_h(options = T.unsafe(nil)); end
  def visit_method; end

  private

  def serialize_value_for_hash(value); end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, arguments, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def comment; end
  def description; end
  def directives; end
  def fields; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_field(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, description, directives, fields, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def directives; end
  def fields; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_field(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, directives, fields, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::InputValueDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def comment; end
  def default_value; end
  def description; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, type, default_value, description, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def comment; end
  def description; end
  def directives; end
  def fields; end
  def interfaces; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_field(**node_opts); end
  def merge_interface(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, description, interfaces, directives, fields, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def directives; end
  def fields; end
  def interfaces; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_field(**node_opts); end
  def merge_interface(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, interfaces, directives, fields, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::ListType < ::GraphQL::Language::Nodes::WrapperType
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def visit_method; end
  end
end

GraphQL::Language::Nodes::NONE = T.let(T.unsafe(nil), Array)

class GraphQL::Language::Nodes::NameOnlyNode < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def marshal_dump; end
  def marshal_load(values); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::NonNullType < ::GraphQL::Language::Nodes::WrapperType
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::NullValue < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::ObjectTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), interfaces: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def comment; end
  def description; end
  def directives; end
  def fields; end
  def interfaces; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_field(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, interfaces, description, directives, fields, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::ObjectTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def directives; end
  def fields; end
  def interfaces; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_field(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, interfaces, directives, fields, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::OperationDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(operation_type: T.unsafe(nil), name: T.unsafe(nil), variables: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def merge_selection(**node_opts); end
  def merge_variable(**node_opts); end
  def name; end
  def operation_type; end
  def scalars; end
  def selections; end
  def variables; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, operation_type, name, variables, directives, selections, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def comment; end
  def description; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, description, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::ScalarTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::SchemaDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def mutation; end
  def query; end
  def scalars; end
  def subscription; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, query, mutation, subscription, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::SchemaExtension < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def mutation; end
  def query; end
  def scalars; end
  def subscription; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, query, mutation, subscription, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::TypeName < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::UnionTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), types: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def comment; end
  def description; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def name; end
  def scalars; end
  def types; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, types, description, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::UnionTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), types: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def children; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def name; end
  def scalars; end
  def types; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, types, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::VariableDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil), directives: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil), definition_pos: T.unsafe(nil)); end

  def children; end
  def default_value; end
  def directives; end
  def marshal_dump; end
  def marshal_load(values); end
  def merge_directive(**node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, name, type, default_value, directives, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::VariableIdentifier < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def visit_method; end
  end
end

class GraphQL::Language::Nodes::WrapperType < ::GraphQL::Language::Nodes::AbstractNode
  def initialize(of_type: T.unsafe(nil), line: T.unsafe(nil), col: T.unsafe(nil), pos: T.unsafe(nil), filename: T.unsafe(nil), source: T.unsafe(nil)); end

  def marshal_dump; end
  def marshal_load(values); end
  def of_type; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
    def from_a(filename, line, col, of_type, comment: T.unsafe(nil)); end
    def visit_method; end
  end
end

class GraphQL::Language::Parser
  include ::GraphQL::Language::Nodes
  include ::GraphQL::EmptyObjects

  def initialize(graphql_str, filename: T.unsafe(nil), trace: T.unsafe(nil), max_tokens: T.unsafe(nil)); end

  def column_at(pos); end
  def line_at(pos); end
  def parse; end
  def tokens_count; end

  private

  def advance_token; end
  def at?(expected_token_name); end
  def debug_token_value; end
  def definition; end
  def document; end
  def expect_one_of(token_names); end
  def expect_token(expected_token_name); end
  def expect_token_value(tok); end
  def lines_at; end
  def list_type; end
  def parse_argument_definitions; end
  def parse_arguments; end
  def parse_directives; end
  def parse_enum_value_definitions; end
  def parse_field_definitions; end
  def parse_implements; end
  def parse_input_object_field_definitions; end
  def parse_input_value_definition; end
  def parse_name; end
  def parse_name_without_on; end
  def parse_operation_type; end
  def parse_type_name; end
  def parse_union_members; end
  def pos; end
  def raise_parse_error(message); end
  def selection_set; end
  def string_value; end
  def token_name; end
  def type; end
  def value; end

  class << self
    def cache; end
    def cache=(_arg0); end
    def parse(graphql_str, filename: T.unsafe(nil), trace: T.unsafe(nil), max_tokens: T.unsafe(nil)); end
    def parse_file(filename, trace: T.unsafe(nil)); end
  end
end

class GraphQL::Language::Parser::SchemaParser < ::GraphQL::Language::Parser
  def initialize(*args, **kwargs); end
end

class GraphQL::Language::Printer
  def print(node, indent: T.unsafe(nil), truncate_size: T.unsafe(nil)); end

  protected

  def print_argument(argument); end
  def print_arguments(arguments, indent: T.unsafe(nil)); end
  def print_comment(node, indent: T.unsafe(nil), first_in_block: T.unsafe(nil)); end
  def print_description(node, indent: T.unsafe(nil), first_in_block: T.unsafe(nil)); end
  def print_description_and_comment(node); end
  def print_directive(directive); end
  def print_directive_definition(directive); end
  def print_directives(directives); end
  def print_document(document); end
  def print_enum(enum); end
  def print_enum_type_definition(enum_type, extension: T.unsafe(nil)); end
  def print_enum_value_definition(enum_value); end
  def print_field(field, indent: T.unsafe(nil)); end
  def print_field_definition(field); end
  def print_field_definitions(fields); end
  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end
  def print_fragment_spread(fragment_spread, indent: T.unsafe(nil)); end
  def print_implements(type); end
  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end
  def print_input_object(input_object); end
  def print_input_object_type_definition(input_object_type, extension: T.unsafe(nil)); end
  def print_input_value_definition(input_value); end
  def print_interface_type_definition(interface_type, extension: T.unsafe(nil)); end
  def print_list_type(list_type); end
  def print_node(node, indent: T.unsafe(nil)); end
  def print_non_null_type(non_null_type); end
  def print_null_value; end
  def print_object_type_definition(object_type, extension: T.unsafe(nil)); end
  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end
  def print_scalar_type_definition(scalar_type, extension: T.unsafe(nil)); end
  def print_schema_definition(schema, extension: T.unsafe(nil)); end
  def print_selections(selections, indent: T.unsafe(nil)); end
  def print_string(str); end
  def print_type_name(type_name); end
  def print_union_type_definition(union_type, extension: T.unsafe(nil)); end
  def print_variable_definition(variable_definition); end
  def print_variable_identifier(variable_identifier); end
end

GraphQL::Language::Printer::OMISSION = T.let(T.unsafe(nil), String)

class GraphQL::Language::Printer::TruncatableBuffer
  def initialize(truncate_size: T.unsafe(nil)); end

  def append(other); end
  def to_string; end
end

GraphQL::Language::Printer::TruncatableBuffer::DEFAULT_INIT_CAPACITY = T.let(T.unsafe(nil), Integer)
class GraphQL::Language::Printer::TruncatableBuffer::TruncateSizeReached < ::StandardError; end

class GraphQL::Language::SanitizedPrinter < ::GraphQL::Language::Printer
  def initialize(query, inline_variables: T.unsafe(nil)); end

  def coerce_argument_value_to_list?(type, value); end
  def print_argument(argument); end
  def print_directive(directive); end
  def print_field(field, indent: T.unsafe(nil)); end
  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end
  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end
  def print_node(node, indent: T.unsafe(nil)); end
  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end
  def print_variable_identifier(variable_id); end
  def redact_argument_value?(argument, value); end
  def redacted_argument_value(argument); end
  def sanitized_query_string; end

  private

  def query; end
  def value_to_ast(value, type); end
end

GraphQL::Language::SanitizedPrinter::REDACTED = T.let(T.unsafe(nil), String)

class GraphQL::Language::StaticVisitor
  def initialize(document); end

  def on_argument(node, parent); end
  def on_argument_children(new_node); end
  def on_directive(node, parent); end
  def on_directive_definition(node, parent); end
  def on_directive_location(node, parent); end
  def on_document(node, parent); end
  def on_document_children(document_node); end
  def on_enum(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_field(node, parent); end
  def on_field_children(new_node); end
  def on_field_definition(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_definition_children(new_node); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_inline_fragment_children(new_node); end
  def on_input_object(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_list_type(node, parent); end
  def on_non_null_type(node, parent); end
  def on_null_value(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_operation_definition(node, parent); end
  def on_operation_definition_children(new_node); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_extension(node, parent); end
  def on_type_name(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_extension(node, parent); end
  def on_variable_definition(node, parent); end
  def on_variable_identifier(node, parent); end
  def visit; end
  def visit_directives(new_node); end
  def visit_selections(new_node); end

  class << self
    def make_visit_methods(ast_node_class); end
  end
end

class GraphQL::Language::Visitor
  def initialize(document); end

  def on_argument(node, parent); end
  def on_argument_children(new_node); end
  def on_argument_with_modifications(node, parent); end
  def on_directive(node, parent); end
  def on_directive_definition(node, parent); end
  def on_directive_definition_with_modifications(node, parent); end
  def on_directive_location(node, parent); end
  def on_directive_location_with_modifications(node, parent); end
  def on_directive_with_modifications(node, parent); end
  def on_document(node, parent); end
  def on_document_children(document_node); end
  def on_document_with_modifications(node, parent); end
  def on_enum(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_definition_with_modifications(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_enum_type_extension_with_modifications(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_enum_value_definition_with_modifications(node, parent); end
  def on_enum_with_modifications(node, parent); end
  def on_field(node, parent); end
  def on_field_children(new_node); end
  def on_field_definition(node, parent); end
  def on_field_definition_with_modifications(node, parent); end
  def on_field_with_modifications(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_definition_children(new_node); end
  def on_fragment_definition_with_modifications(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_fragment_spread_with_modifications(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_inline_fragment_children(new_node); end
  def on_inline_fragment_with_modifications(node, parent); end
  def on_input_object(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_definition_with_modifications(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_input_object_type_extension_with_modifications(node, parent); end
  def on_input_object_with_modifications(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_input_value_definition_with_modifications(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_definition_with_modifications(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_interface_type_extension_with_modifications(node, parent); end
  def on_list_type(node, parent); end
  def on_list_type_with_modifications(node, parent); end
  def on_non_null_type(node, parent); end
  def on_non_null_type_with_modifications(node, parent); end
  def on_null_value(node, parent); end
  def on_null_value_with_modifications(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_definition_with_modifications(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_object_type_extension_with_modifications(node, parent); end
  def on_operation_definition(node, parent); end
  def on_operation_definition_children(new_node); end
  def on_operation_definition_with_modifications(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_definition_with_modifications(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_scalar_type_extension_with_modifications(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_definition_with_modifications(node, parent); end
  def on_schema_extension(node, parent); end
  def on_schema_extension_with_modifications(node, parent); end
  def on_type_name(node, parent); end
  def on_type_name_with_modifications(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_definition_with_modifications(node, parent); end
  def on_union_type_extension(node, parent); end
  def on_union_type_extension_with_modifications(node, parent); end
  def on_variable_definition(node, parent); end
  def on_variable_definition_with_modifications(node, parent); end
  def on_variable_identifier(node, parent); end
  def on_variable_identifier_with_modifications(node, parent); end
  def result; end
  def visit; end
  def visit_directives(new_node); end
  def visit_selections(new_node); end

  private

  def apply_modifications(node, parent, new_node_and_new_parent); end

  class << self
    def make_visit_methods(ast_node_class); end
  end
end

GraphQL::Language::Visitor::DELETE_NODE = T.let(T.unsafe(nil), GraphQL::Language::Visitor::DeleteNode)
class GraphQL::Language::Visitor::DeleteNode; end

class GraphQL::LoadApplicationObjectFailedError < ::GraphQL::ExecutionError
  def initialize(argument:, id:, object:, context:); end

  def argument; end
  def context; end
  def id; end
  def object; end
end

GraphQL::NOT_CONFIGURED = T.let(T.unsafe(nil), Object)

class GraphQL::NameValidator
  class << self
    def validate!(name); end
  end
end

GraphQL::NameValidator::VALID_NAME_REGEX = T.let(T.unsafe(nil), Regexp)
module GraphQL::Pagination; end

class GraphQL::Pagination::ActiveRecordRelationConnection < ::GraphQL::Pagination::RelationConnection
  private

  def already_loaded?(relation); end
  def null_relation(relation); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
  def set_limit(nodes, limit); end
  def set_offset(nodes, offset); end
end

class GraphQL::Pagination::ArrayConnection < ::GraphQL::Pagination::Connection
  def cursor_for(item); end
  def has_next_page; end
  def has_previous_page; end
  def nodes; end

  private

  def index_from_cursor(cursor); end
  def load_nodes; end
end

class GraphQL::Pagination::Connection
  def initialize(items, parent: T.unsafe(nil), field: T.unsafe(nil), context: T.unsafe(nil), first: T.unsafe(nil), after: T.unsafe(nil), max_page_size: T.unsafe(nil), default_page_size: T.unsafe(nil), last: T.unsafe(nil), before: T.unsafe(nil), edge_class: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def after; end
  def after_value; end
  def after_value=(_arg0); end
  def arguments; end
  def arguments=(_arg0); end
  def before; end
  def before_value; end
  def before_value=(_arg0); end
  def context; end
  def context=(new_ctx); end
  def cursor_for(item); end
  def default_page_size; end
  def default_page_size=(new_value); end
  def edge_class; end
  def edge_class=(_arg0); end
  def edge_nodes; end
  def edges; end
  def end_cursor; end
  def field; end
  def field=(_arg0); end
  def first; end
  def first=(_arg0); end
  def first_value; end
  def first_value=(_arg0); end
  def has_default_page_size_override?; end
  def has_max_page_size_override?; end
  def has_next_page; end
  def has_previous_page; end
  def items; end
  def last; end
  def last=(_arg0); end
  def last_value; end
  def last_value=(_arg0); end
  def max_page_size; end
  def max_page_size=(new_value); end
  def nodes; end
  def page_info; end
  def parent; end
  def parent=(_arg0); end
  def range_add_edge(item); end
  def start_cursor; end
  def was_authorized_by_scope_items?; end

  private

  def decode(cursor); end
  def detect_was_authorized_by_scope_items; end
  def encode(cursor); end
  def limit_pagination_argument(argument, max_page_size); end
end

class GraphQL::Pagination::Connection::Edge
  def initialize(node, connection); end

  def cursor; end
  def node; end
  def parent; end
  def was_authorized_by_scope_items?; end
end

class GraphQL::Pagination::Connection::PaginationImplementationMissingError < ::GraphQL::Error; end

class GraphQL::Pagination::Connections
  def initialize(schema:); end

  def add(nodes_class, implementation); end
  def all_wrappers; end
  def delete(nodes_class); end
  def edge_class_for_field(field); end
  def wrap(field, parent, items, arguments, context); end
  def wrapper_for(items, wrappers: T.unsafe(nil)); end

  protected

  def wrappers; end

  private

  def add_default; end
end

class GraphQL::Pagination::Connections::ImplementationMissingError < ::GraphQL::Error; end

class GraphQL::Pagination::MongoidRelationConnection < ::GraphQL::Pagination::RelationConnection
  def null_relation(relation); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end

class GraphQL::Pagination::RelationConnection < ::GraphQL::Pagination::Connection
  def cursor_for(item); end
  def has_next_page; end
  def has_previous_page; end
  def nodes; end

  private

  def after_offset; end
  def before_offset; end
  def calculate_sliced_nodes_parameters; end
  def limited_nodes; end
  def load_nodes; end
  def null_relation(relation); end
  def offset_from_cursor(cursor); end
  def relation_count(relation); end
  def relation_larger_than(relation, _initial_offset, size); end
  def relation_limit(relation); end
  def relation_offset(relation); end
  def set_limit(relation, limit_value); end
  def set_offset(relation, offset_value); end
  def sliced_nodes; end
end

class GraphQL::Pagination::SequelDatasetConnection < ::GraphQL::Pagination::RelationConnection
  private

  def null_relation(relation); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end

class GraphQL::ParseError < ::GraphQL::Error
  def initialize(message, line, col, query, filename: T.unsafe(nil)); end

  def col; end
  def line; end
  def query; end
  def to_h; end
end

class GraphQL::Query
  include ::GraphQL::Tracing::Traceable
  extend ::GraphQL::Autoload
  extend ::Forwardable

  def initialize(schema, query_string = T.unsafe(nil), query: T.unsafe(nil), document: T.unsafe(nil), context: T.unsafe(nil), variables: T.unsafe(nil), validate: T.unsafe(nil), static_validator: T.unsafe(nil), visibility_profile: T.unsafe(nil), subscription_topic: T.unsafe(nil), operation_name: T.unsafe(nil), root_value: T.unsafe(nil), max_depth: T.unsafe(nil), max_complexity: T.unsafe(nil), warden: T.unsafe(nil), use_visibility_profile: T.unsafe(nil)); end

  def after_lazy(value, &block); end
  def analysis_errors; end
  def analysis_errors=(_arg0); end
  def analyzers(*args, **_arg1, &block); end
  def arguments_cache; end
  def arguments_for(ast_node, definition, parent_object: T.unsafe(nil)); end
  def ast_analyzers(*args, **_arg1, &block); end
  def context; end
  def current_trace; end
  def document; end
  def executed?; end
  def fingerprint; end
  def fragments; end
  def get_field(owner, field_name); end
  def get_type(type_name); end
  def handle_or_reraise(err); end
  def inspect; end
  def logger; end
  def lookahead; end
  def max_complexity(*args, **_arg1, &block); end
  def max_depth(*args, **_arg1, &block); end
  def multiplex; end
  def multiplex=(_arg0); end
  def mutation?; end
  def operation_fingerprint; end
  def operation_name; end
  def operation_name=(_arg0); end
  def operations; end
  def possible_types(type); end
  def provided_variables; end
  def query?; end
  def query_string; end
  def query_string=(_arg0); end
  def resolve_type(abstract_type, value = T.unsafe(nil)); end
  def result; end
  def result_values; end
  def result_values=(result_hash); end
  def root_type_for_operation(op_type); end
  def root_value; end
  def root_value=(_arg0); end
  def sanitized_query_string(inline_variables: T.unsafe(nil)); end
  def schema; end
  def selected_operation; end
  def selected_operation_name; end
  def static_errors; end
  def static_validator; end
  def static_validator=(new_validator); end
  def subscription?; end
  def subscription_topic; end
  def subscription_update?; end
  def tracers; end
  def types; end
  def valid?; end
  def validate; end
  def validate=(new_validate); end
  def validate_timeout_remaining(*args, **_arg1, &block); end
  def validation_errors(*args, **_arg1, &block); end
  def validation_pipeline; end
  def variables; end
  def variables_fingerprint; end
  def visibility_profile; end
  def warden; end

  private

  def find_operation(operations, operation_name); end
  def prepare_ast; end
  def with_prepared_ast; end
end

class GraphQL::Query::Context
  extend ::Forwardable

  def initialize(query:, values:, schema: T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def add_error(error); end
  def backtrace; end
  def current_path; end
  def dataloader; end
  def delete(key); end
  def dig(key, *other_keys); end
  def errors; end
  def execution_errors; end
  def fetch(key, default = T.unsafe(nil)); end
  def inspect; end
  def interpreter=(_arg0); end
  def key?(key); end
  def logger; end
  def namespace(ns); end
  def namespace?(ns); end
  def path; end
  def query; end
  def response_extensions; end
  def schema; end
  def scoped; end
  def scoped_context; end
  def scoped_merge!(hash); end
  def scoped_set!(key, value); end
  def skip; end
  def to_h; end
  def to_hash; end
  def trace(*args, **_arg1, &block); end
  def types; end
  def types=(_arg0); end
  def value=(_arg0); end
  def warden; end
  def warden=(_arg0); end
end

class GraphQL::Query::Context::ExecutionErrors
  def initialize(ctx); end

  def >>(err_or_msg); end
  def add(err_or_msg); end
  def push(err_or_msg); end
end

GraphQL::Query::Context::RUNTIME_METADATA_KEYS = T.let(T.unsafe(nil), Set)

class GraphQL::Query::Context::Scoped
  def initialize(scoped_context, path); end

  def merge!(hash); end
  def set!(key, value); end
end

class GraphQL::Query::Context::ScopedContext
  def initialize(query_context); end

  def [](key); end
  def current_path; end
  def dig(key, *other_keys); end
  def key?(key); end
  def merge!(hash, at: T.unsafe(nil)); end
  def merged_context; end

  private

  def each_present_path_ctx; end
end

GraphQL::Query::Context::UNSPECIFIED_FETCH_DEFAULT = T.let(T.unsafe(nil), Object)

module GraphQL::Query::Fingerprint
  class << self
    def generate(input_str); end
  end
end

class GraphQL::Query::InputValidationResult
  def initialize(valid: T.unsafe(nil), problems: T.unsafe(nil)); end

  def add_problem(explanation, path = T.unsafe(nil), extensions: T.unsafe(nil), message: T.unsafe(nil)); end
  def merge_result!(path, inner_result); end
  def problems; end
  def problems=(_arg0); end
  def valid?; end

  class << self
    def from_problem(explanation, path = T.unsafe(nil), extensions: T.unsafe(nil), message: T.unsafe(nil)); end
  end
end

GraphQL::Query::InputValidationResult::VALID = T.let(T.unsafe(nil), GraphQL::Query::InputValidationResult)

class GraphQL::Query::NullContext < ::GraphQL::Query::Context
  include ::Singleton::SingletonInstanceMethods
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def initialize; end

  def [](*args, **_arg1, &block); end
  def dataloader; end
  def dig(*args, **_arg1, &block); end
  def fetch(*args, **_arg1, &block); end
  def key?(*args, **_arg1, &block); end
  def query; end
  def schema; end
  def to_h(*args, **_arg1, &block); end
  def warden; end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

class GraphQL::Query::NullContext::NullQuery
  def after_lazy(value); end
end

class GraphQL::Query::NullContext::NullSchema < ::GraphQL::Schema; end

class GraphQL::Query::OperationNameMissingError < ::GraphQL::ExecutionError
  def initialize(name); end
end

class GraphQL::Query::Result
  extend ::Forwardable

  def initialize(query:, values:); end

  def ==(other); end
  def [](*args, **_arg1, &block); end
  def as_json(*args, **_arg1, &block); end
  def context(*args, **_arg1, &block); end
  def inspect; end
  def keys(*args, **_arg1, &block); end
  def method_missing(method_name, *args, &block); end
  def mutation?(*args, **_arg1, &block); end
  def query; end
  def query?(*args, **_arg1, &block); end
  def subscription?(*args, **_arg1, &block); end
  def to_h; end
  def to_json(*args, **_arg1, &block); end
  def values(*args, **_arg1, &block); end

  private

  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
end

class GraphQL::Query::ValidationPipeline
  def initialize(query:, parse_error:, operation_name_error:, max_depth:, max_complexity:); end

  def analyzers; end
  def has_validated?; end
  def max_complexity; end
  def max_depth; end
  def valid?; end
  def validate_timeout_remaining; end
  def validation_errors; end

  private

  def build_analyzers(schema, max_depth, max_complexity); end
  def ensure_has_validated; end
end

class GraphQL::Query::VariableValidationError < ::GraphQL::ExecutionError
  def initialize(variable_ast, type, value, validation_result, msg: T.unsafe(nil)); end

  def to_h; end
  def validation_result; end
  def validation_result=(_arg0); end
  def value; end
  def value=(_arg0); end

  private

  def problem_fields; end
end

class GraphQL::Query::Variables
  extend ::Forwardable

  def initialize(ctx, ast_variables, provided_variables); end

  def [](*args, **_arg1, &block); end
  def context; end
  def errors; end
  def fetch(*args, **_arg1, &block); end
  def key?(*args, **_arg1, &block); end
  def length(*args, **_arg1, &block); end
  def to_h(*args, **_arg1, &block); end

  private

  def add_max_errors_reached_message; end
  def deep_stringify(val); end
end

module GraphQL::Relay; end

class GraphQL::Relay::RangeAdd
  def initialize(collection:, item:, context:, parent: T.unsafe(nil), edge_class: T.unsafe(nil)); end

  def connection; end
  def edge; end
  def parent; end
end

class GraphQL::RequiredImplementationMissingError < ::GraphQL::Error; end
class GraphQL::RuntimeTypeError < ::GraphQL::Error; end

class GraphQL::Schema
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::EmptyObjects
  extend ::GraphQL::Autoload

  class << self
    def add_subscription_extension_if_necessary; end
    def after_any_lazies(maybe_lazies); end
    def after_lazy(value, &block); end
    def analysis_engine; end
    def analysis_engine=(_arg0); end
    def as_json(context: T.unsafe(nil), include_deprecated_args: T.unsafe(nil), include_schema_description: T.unsafe(nil), include_is_repeatable: T.unsafe(nil), include_specified_by_url: T.unsafe(nil), include_is_one_of: T.unsafe(nil)); end
    def build_trace_mode(mode); end
    def connections; end
    def connections=(_arg0); end
    def context_class(new_context_class = T.unsafe(nil)); end
    def count_introspection_fields; end
    def cursor_encoder(new_encoder = T.unsafe(nil)); end
    def dataloader_class; end
    def dataloader_class=(_arg0); end
    def default_analysis_engine; end
    def default_directives; end
    def default_execution_strategy; end
    def default_logger(new_default_logger = T.unsafe(nil)); end
    def default_max_page_size(new_default_max_page_size = T.unsafe(nil)); end
    def default_page_size(new_default_page_size = T.unsafe(nil)); end
    def default_trace_mode(new_mode = T.unsafe(nil)); end
    def deprecated_graphql_definition; end
    def description(new_description = T.unsafe(nil)); end
    def did_you_mean(new_dym = T.unsafe(nil)); end
    def directive(new_directive); end
    def directives(*new_directives); end
    def disable_introspection_entry_points; end
    def disable_introspection_entry_points?; end
    def disable_schema_introspection_entry_point; end
    def disable_schema_introspection_entry_point?; end
    def disable_type_introspection_entry_point; end
    def disable_type_introspection_entry_point?; end
    def error_bubbling(new_error_bubbling = T.unsafe(nil)); end
    def error_bubbling=(_arg0); end
    def error_handlers; end
    def execute(query_str = T.unsafe(nil), **kwargs); end
    def extra_types(*new_extra_types); end
    def find(path); end
    def from_definition(definition_or_path, default_resolve: T.unsafe(nil), parser: T.unsafe(nil), using: T.unsafe(nil)); end
    def from_introspection(introspection_result); end
    def get_field(type_or_name, field_name, context = T.unsafe(nil)); end
    def get_fields(type, context = T.unsafe(nil)); end
    def get_type(type_name, context = T.unsafe(nil), use_visibility_profile = T.unsafe(nil)); end
    def handle_or_reraise(context, err); end
    def has_defined_type?(type_name); end
    def id_from_object(application_object, graphql_type, context); end
    def inherited(child_class); end
    def instrument(instrument_step, instrumenter, options = T.unsafe(nil)); end
    def instrumenters; end
    def introspection(new_introspection_namespace = T.unsafe(nil)); end
    def introspection_system; end
    def lazy?(obj); end
    def lazy_method_name(obj); end
    def lazy_resolve(lazy_class, value_method); end
    def load_type(type_name, ctx); end
    def max_complexity(max_complexity = T.unsafe(nil), count_introspection_fields: T.unsafe(nil)); end
    def max_complexity=(_arg0); end
    def max_complexity_count_introspection_fields; end
    def max_depth(new_max_depth = T.unsafe(nil), count_introspection_fields: T.unsafe(nil)); end
    def max_depth=(_arg0); end
    def max_query_string_tokens(new_max_tokens = T.unsafe(nil)); end
    def multiplex(queries, **kwargs); end
    def multiplex_analyzer(new_analyzer); end
    def multiplex_analyzers; end
    def mutation(new_mutation_object = T.unsafe(nil), &lazy_load_block); end
    def mutation_execution_strategy(new_mutation_execution_strategy = T.unsafe(nil), deprecation_warning: T.unsafe(nil)); end
    def new_trace(mode: T.unsafe(nil), **options); end
    def object_from_id(object_id, context); end
    def orphan_types(*new_orphan_types); end
    def own_trace_modes; end
    def own_trace_modules; end
    def parse_error(parse_err, ctx); end
    def plugins; end
    def possible_types(type = T.unsafe(nil), context = T.unsafe(nil), use_visibility_profile = T.unsafe(nil)); end
    def query(new_query_object = T.unsafe(nil), &lazy_load_block); end
    def query_analyzer(new_analyzer); end
    def query_analyzers; end
    def query_class(new_query_class = T.unsafe(nil)); end
    def query_execution_strategy(new_query_execution_strategy = T.unsafe(nil), deprecation_warning: T.unsafe(nil)); end
    def query_stack_error(query, err); end
    def references_to(to_type = T.unsafe(nil), from: T.unsafe(nil)); end
    def rescue_from(*err_classes, &handler_block); end
    def resolve_type(abstract_type, application_object, context); end
    def root_type_for_operation(operation); end
    def root_types; end
    def sanitized_printer(new_sanitized_printer = T.unsafe(nil)); end
    def schema_directive(dir_class, **options); end
    def schema_directives; end
    def static_validator; end
    def subscription(new_subscription_object = T.unsafe(nil), &lazy_load_block); end
    def subscription_execution_strategy(new_subscription_execution_strategy = T.unsafe(nil), deprecation_warning: T.unsafe(nil)); end
    def subscriptions(inherited: T.unsafe(nil)); end
    def subscriptions=(new_implementation); end
    def sync_lazy(value); end
    def to_definition(context: T.unsafe(nil)); end
    def to_document; end
    def to_json(**args); end
    def trace_class(new_class = T.unsafe(nil)); end
    def trace_class_for(mode, build: T.unsafe(nil)); end
    def trace_mode(mode_name, trace_class); end
    def trace_modules_for(trace_mode); end
    def trace_options_for(mode); end
    def trace_with(trace_mod, mode: T.unsafe(nil), **options); end
    def tracer(new_tracer, silence_deprecation_warning: T.unsafe(nil)); end
    def tracers; end
    def type_error(type_error, ctx); end
    def type_from_ast(ast_node, context: T.unsafe(nil)); end
    def types(context = T.unsafe(nil)); end
    def unauthorized_field(unauthorized_error); end
    def unauthorized_object(unauthorized_error); end
    def union_memberships(type = T.unsafe(nil)); end
    def use(plugin, **kwargs); end
    def use_visibility_profile=(_arg0); end
    def use_visibility_profile?; end
    def using_backtrace; end
    def using_backtrace=(_arg0); end
    def validate(string_or_document, rules: T.unsafe(nil), context: T.unsafe(nil)); end
    def validate_max_errors(new_validate_max_errors = T.unsafe(nil)); end
    def validate_max_errors=(_arg0); end
    def validate_timeout(new_validate_timeout = T.unsafe(nil)); end
    def validate_timeout=(_arg0); end
    def visibility; end
    def visibility=(_arg0); end
    def visibility_profile_class; end
    def visibility_profile_class=(_arg0); end
    def visible?(member, ctx); end
    def warden_class; end
    def warden_class=(_arg0); end

    private

    def add_trace_options_for(mode, new_options); end
    def add_type_and_traverse(t, root:); end
    def get_references_to(type_defn); end
    def lazy_methods; end
    def non_introspection_types; end
    def own_directives; end
    def own_instrumenters; end
    def own_multiplex_analyzers; end
    def own_orphan_types; end
    def own_plugins; end
    def own_possible_types; end
    def own_query_analyzers; end
    def own_references_to; end
    def own_tracers; end
    def own_types; end
    def own_union_memberships; end
  end
end

class GraphQL::Schema::Addition
  def initialize(schema:, own_types:, new_types:); end

  def arguments_with_default_values; end
  def directives; end
  def possible_types; end
  def references; end
  def types; end
  def union_memberships; end

  private

  def add_directives_from(owner); end
  def add_type(type, owner:, late_types:, path:); end
  def add_type_and_traverse(new_types); end
  def get_local_type(name); end
  def get_type(name); end
  def references_to(thing, from:); end
  def update_type_owner(owner, type); end
end

module GraphQL::Schema::AlwaysVisible
  def visible?(_member, _context); end

  class << self
    def use(schema, **opts); end
  end
end

class GraphQL::Schema::Argument
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason
  include ::GraphQL::EmptyObjects
  include ::GraphQL::Schema::Member::HasValidators

  def initialize(arg_name = T.unsafe(nil), type_expr = T.unsafe(nil), desc = T.unsafe(nil), owner:, required: T.unsafe(nil), type: T.unsafe(nil), name: T.unsafe(nil), loads: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), ast_node: T.unsafe(nil), default_value: T.unsafe(nil), as: T.unsafe(nil), from_resolver: T.unsafe(nil), camelize: T.unsafe(nil), prepare: T.unsafe(nil), validates: T.unsafe(nil), directives: T.unsafe(nil), deprecation_reason: T.unsafe(nil), replace_null_with_default: T.unsafe(nil), &definition_block); end

  def authorized?(obj, value, ctx); end
  def authorized_as_type?(obj, value, ctx, as_type:); end
  def coerce_into_values(parent_object, values, context, argument_values); end
  def comment(text = T.unsafe(nil)); end
  def comment=(_arg0); end
  def default_value(new_default_value = T.unsafe(nil)); end
  def default_value?; end
  def deprecation_reason(text = T.unsafe(nil)); end
  def deprecation_reason=(new_reason); end
  def description(text = T.unsafe(nil)); end
  def description=(_arg0); end
  def from_resolver?; end
  def graphql_name; end
  def inspect; end
  def keyword; end
  def load_and_authorize_value(load_method_owner, coerced_value, context); end
  def loads; end
  def name; end
  def owner; end
  def prepare(new_prepare = T.unsafe(nil)); end
  def prepare_value(obj, value, context: T.unsafe(nil)); end
  def replace_null_with_default?; end
  def statically_coercible?; end
  def type; end
  def type=(new_type); end
  def validate_default_value; end
  def visible?(context); end

  private

  def recursively_prepare_input_object(value, type); end
  def validate_deprecated_or_optional(null:, deprecation_reason:); end
  def validate_input_type(input_type); end
end

class GraphQL::Schema::Argument::InvalidDefaultValueError < ::GraphQL::Error
  def initialize(argument); end
end

GraphQL::Schema::BUILT_IN_TYPES = T.let(T.unsafe(nil), Hash)

module GraphQL::Schema::Base64Encoder
  class << self
    def decode(encoded_text, nonce: T.unsafe(nil)); end
    def encode(unencoded_text, nonce: T.unsafe(nil)); end
  end
end

module GraphQL::Schema::BuildFromDefinition
  class << self
    def from_definition(schema_superclass, definition_string, parser: T.unsafe(nil), **kwargs); end
    def from_definition_path(schema_superclass, definition_path, parser: T.unsafe(nil), **kwargs); end
    def from_document(schema_superclass, document, default_resolve:, using: T.unsafe(nil), relay: T.unsafe(nil)); end
  end
end

module GraphQL::Schema::BuildFromDefinition::Builder
  include ::GraphQL::EmptyObjects
  extend ::GraphQL::EmptyObjects
  extend ::GraphQL::Schema::BuildFromDefinition::Builder

  def args_to_kwargs(arg_owner, node); end
  def build(schema_superclass, document, default_resolve:, relay:, using: T.unsafe(nil)); end
  def build_arguments(type_class, arguments, type_resolver); end
  def build_default_value(default_value); end
  def build_definition_from_node(definition, type_resolver, default_resolve); end
  def build_deprecation_reason(directives); end
  def build_directive(directive_definition, type_resolver); end
  def build_directives(definition, ast_node, type_resolver); end
  def build_enum_type(enum_type_definition, type_resolver); end
  def build_fields(owner, field_definitions, type_resolver, default_resolve:); end
  def build_input_object_type(input_object_type_definition, type_resolver); end
  def build_interface_type(interface_type_definition, type_resolver); end
  def build_object_type(object_type_definition, type_resolver); end
  def build_resolve_type(lookup_hash, directives, missing_type_handler); end
  def build_scalar_type(scalar_type_definition, type_resolver, default_resolve:); end
  def build_scalar_type_coerce_method(scalar_class, method_name, default_definition_resolve); end
  def build_union_type(union_type_definition, type_resolver); end
  def prepare_directives(ast_node, type_resolver); end
  def replace_late_bound_types_with_built_in(types); end
end

GraphQL::Schema::BuildFromDefinition::Builder::NullResolveType = T.let(T.unsafe(nil), Proc)

class GraphQL::Schema::BuildFromDefinition::ResolveMap
  def initialize(user_resolve_hash); end

  def call(type, field, obj, args, ctx); end
  def coerce_input(type, value, ctx); end
  def coerce_result(type, value, ctx); end
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap::DefaultResolve
  def initialize(field_map, field_name); end

  def call(obj, args, ctx); end
end

module GraphQL::Schema::BuildFromDefinition::ResolveMap::NullScalarCoerce
  class << self
    def call(val, _ctx); end
  end
end

module GraphQL::Schema::DefaultTraceClass; end

class GraphQL::Schema::Directive < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured
  extend ::GraphQL::Schema::Member::HasArguments::HasDirectiveArguments

  def initialize(owner, **arguments); end

  def arguments; end
  def graphql_name; end
  def owner; end

  private

  def assert_has_location(location); end
  def assert_valid_owner; end

  class << self
    def default_directive(new_default_directive = T.unsafe(nil)); end
    def default_directive?; end
    def default_graphql_name; end
    def include?(_object, arguments, context); end
    def locations(*new_locations); end
    def on_field?; end
    def on_fragment?; end
    def on_operation?; end
    def path; end
    def repeatable(new_value); end
    def repeatable?; end
    def resolve(object, arguments, context); end
    def resolve_each(object, arguments, context); end
    def static_include?(_arguments, _context); end

    private

    def inherited(subclass); end
  end
end

GraphQL::Schema::Directive::ARGUMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::DEFAULT_DEPRECATION_REASON = T.let(T.unsafe(nil), String)

class GraphQL::Schema::Directive::Deprecated < ::GraphQL::Schema::Directive
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments
end

GraphQL::Schema::Directive::ENUM = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::ENUM_VALUE = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FIELD = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FRAGMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FRAGMENT_SPREAD = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Directive::Feature < ::GraphQL::Schema::Directive
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments

  class << self
    def enabled?(flag_name, object, context); end
    def include?(object, arguments, context); end
  end
end

class GraphQL::Schema::Directive::Flagged < ::GraphQL::Schema::Directive
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments

  def initialize(target, **options); end
end

module GraphQL::Schema::Directive::Flagged::VisibleByFlag
  def visible?(context); end

  class << self
    def included(schema_class); end
  end
end

GraphQL::Schema::Directive::INLINE_FRAGMENT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INPUT_FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INPUT_OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INTERFACE = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Directive::Include < ::GraphQL::Schema::Directive
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments

  class << self
    def static_include?(args, ctx); end
  end
end

GraphQL::Schema::Directive::LOCATIONS = T.let(T.unsafe(nil), Array)
GraphQL::Schema::Directive::LOCATION_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)
GraphQL::Schema::Directive::MUTATION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::OBJECT = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Directive::OneOf < ::GraphQL::Schema::Directive
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments

  def initialize(*_arg0, **_arg1, &_arg2); end
end

module GraphQL::Schema::Directive::OneOf::IsOneOf
  def one_of?; end
end

GraphQL::Schema::Directive::QUERY = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SCALAR = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SCHEMA = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SUBSCRIPTION = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Directive::Skip < ::GraphQL::Schema::Directive
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments

  class << self
    def static_include?(args, ctx); end
  end
end

class GraphQL::Schema::Directive::SpecifiedBy < ::GraphQL::Schema::Directive
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments
end

class GraphQL::Schema::Directive::Transform < ::GraphQL::Schema::Directive
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments

  class << self
    def resolve(object, arguments, context); end
  end
end

GraphQL::Schema::Directive::Transform::TRANSFORMS = T.let(T.unsafe(nil), Array)
GraphQL::Schema::Directive::UNION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::VARIABLE_DEFINITION = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::DuplicateNamesError < ::GraphQL::Error
  def initialize(duplicated_name:, duplicated_definition_1:, duplicated_definition_2:); end

  def duplicated_name; end
end

class GraphQL::Schema::Enum < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::ValidatesInput

  class << self
    def all_enum_value_definitions; end
    def coerce_input(value_name, ctx); end
    def coerce_result(value, ctx); end
    def enum_value_class(new_enum_value_class = T.unsafe(nil)); end
    def enum_values(context = T.unsafe(nil)); end
    def inherited(child_class); end
    def kind; end
    def validate_non_null_input(value_name, ctx, max_errors: T.unsafe(nil)); end
    def value(*args, value_method: T.unsafe(nil), **kwargs, &block); end
    def values(context = T.unsafe(nil)); end

    private

    def generate_value_method(value, configured_value_method); end
    def own_values; end
  end
end

class GraphQL::Schema::Enum::MissingValuesError < ::GraphQL::Error
  def initialize(enum_type); end
end

class GraphQL::Schema::Enum::UnresolvedValueError < ::GraphQL::Error
  def initialize(value:, enum:, context:, authorized:); end
end

class GraphQL::Schema::EnumValue < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason

  def initialize(graphql_name, desc = T.unsafe(nil), owner:, ast_node: T.unsafe(nil), directives: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), value: T.unsafe(nil), deprecation_reason: T.unsafe(nil), &block); end

  def authorized?(_ctx); end
  def comment(new_comment = T.unsafe(nil)); end
  def description(new_desc = T.unsafe(nil)); end
  def graphql_name; end
  def inspect; end
  def owner; end
  def value(new_val = T.unsafe(nil)); end
  def visible?(_ctx); end
end

class GraphQL::Schema::Field
  include ::GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasArguments::FieldConfigured
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::EmptyObjects
  include ::GraphQL::Schema::Member::HasValidators
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::EmptyObjects

  def initialize(type: T.unsafe(nil), name: T.unsafe(nil), owner: T.unsafe(nil), null: T.unsafe(nil), description: T.unsafe(nil), comment: T.unsafe(nil), deprecation_reason: T.unsafe(nil), method: T.unsafe(nil), hash_key: T.unsafe(nil), dig: T.unsafe(nil), resolver_method: T.unsafe(nil), connection: T.unsafe(nil), max_page_size: T.unsafe(nil), default_page_size: T.unsafe(nil), scope: T.unsafe(nil), introspection: T.unsafe(nil), camelize: T.unsafe(nil), trace: T.unsafe(nil), complexity: T.unsafe(nil), ast_node: T.unsafe(nil), extras: T.unsafe(nil), extensions: T.unsafe(nil), connection_extension: T.unsafe(nil), resolver_class: T.unsafe(nil), subscription_scope: T.unsafe(nil), relay_node_field: T.unsafe(nil), relay_nodes_field: T.unsafe(nil), method_conflict_warning: T.unsafe(nil), broadcastable: T.unsafe(nil), arguments: T.unsafe(nil), directives: T.unsafe(nil), validates: T.unsafe(nil), fallback_value: T.unsafe(nil), dynamic_introspection: T.unsafe(nil), &definition_block); end

  def authorized?(object, args, context); end
  def broadcastable?; end
  def calculate_complexity(query:, nodes:, child_complexity:); end
  def comment(text = T.unsafe(nil)); end
  def complexity(new_complexity = T.unsafe(nil)); end
  def connection?; end
  def default_page_size; end
  def description(text = T.unsafe(nil)); end
  def description=(_arg0); end
  def dig_keys; end
  def directives; end
  def dynamic_introspection; end
  def dynamic_introspection=(_arg0); end
  def ensure_loaded; end
  def extension(extension_class, **options); end
  def extensions(new_extensions = T.unsafe(nil)); end
  def extras(new_extras = T.unsafe(nil)); end
  def fetch_extra(extra_name, ctx); end
  def graphql_name; end
  def has_default_page_size?; end
  def has_max_page_size?; end
  def hash_key; end
  def inspect; end
  def introspection?; end
  def max_page_size; end
  def method_conflict_warning?; end
  def method_str; end
  def method_sym; end
  def mutation; end
  def name; end
  def original_name; end
  def owner; end
  def owner=(_arg0); end
  def owner_type; end
  def relay_node_field; end
  def relay_nodes_field; end
  def resolve(object, args, query_ctx); end
  def resolver; end
  def resolver_method; end
  def scoped?; end
  def subscription_scope; end
  def subscription_scope=(_arg0); end
  def trace; end
  def type(new_type = T.unsafe(nil)); end
  def type=(_arg0); end
  def visible?(context); end

  private

  def apply_own_complexity_to(child_complexity, query, nodes); end
  def assert_satisfactory_implementation(receiver, method_name, ruby_kwargs); end
  def run_extensions_before_resolve(obj, args, ctx, extended, idx: T.unsafe(nil)); end
  def set_pagination_extensions(connection_extension:); end
  def with_extensions(obj, args, ctx); end

  class << self
    def connection_extension(new_extension_class = T.unsafe(nil)); end
    def from_options(name = T.unsafe(nil), type = T.unsafe(nil), desc = T.unsafe(nil), comment: T.unsafe(nil), resolver: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), **kwargs, &block); end
  end
end

class GraphQL::Schema::Field::ConnectionExtension < ::GraphQL::Schema::FieldExtension
  def after_resolve(value:, object:, arguments:, context:, memo:); end
  def apply; end
  def resolve(object:, arguments:, context:); end
end

class GraphQL::Schema::Field::ExtendedState
  def initialize(args, object); end

  def added_extras; end
  def added_extras=(_arg0); end
  def arguments; end
  def arguments=(_arg0); end
  def memos; end
  def memos=(_arg0); end
  def object; end
  def object=(_arg0); end
end

class GraphQL::Schema::Field::FieldImplementationFailed < ::GraphQL::Error; end
class GraphQL::Schema::Field::MissingReturnTypeError < ::GraphQL::Error; end

class GraphQL::Schema::Field::ScopeExtension < ::GraphQL::Schema::FieldExtension
  def after_resolve(object:, arguments:, context:, value:, memo:); end
end

class GraphQL::Schema::FieldExtension
  def initialize(field:, options:); end

  def added_default_arguments; end
  def added_extras; end
  def after_define; end
  def after_define_apply; end
  def after_resolve(object:, arguments:, context:, value:, memo:); end
  def apply; end
  def field; end
  def options; end
  def resolve(object:, arguments:, context:); end

  class << self
    def default_argument(*argument_args, **argument_kwargs); end
    def default_argument_configurations; end
    def extras(new_extras = T.unsafe(nil)); end
  end
end

module GraphQL::Schema::FindInheritedValue
  include ::GraphQL::EmptyObjects

  private

  def find_inherited_value(method_name, default_value = T.unsafe(nil)); end

  class << self
    def extended(child_cls); end
    def included(child_cls); end
  end
end

class GraphQL::Schema::Finder
  def initialize(schema); end

  def find(path); end

  private

  def find_in_directive(directive, path:); end
  def find_in_enum_type(enum_type, path:); end
  def find_in_field(field, path:); end
  def find_in_fields_type(type, kind:, path:); end
  def find_in_input_object(input_object, path:); end
  def find_in_type(type, path:); end
  def schema; end
end

class GraphQL::Schema::Finder::MemberNotFoundError < ::ArgumentError; end

module GraphQL::Schema::HasSingleInputArgument
  mixes_in_class_methods ::GraphQL::Schema::HasSingleInputArgument::ClassMethods

  def resolve_with_support(**inputs); end

  private

  def authorize_arguments(args, values); end

  class << self
    def included(base); end
  end
end

module GraphQL::Schema::HasSingleInputArgument::ClassMethods
  def all_field_argument_definitions; end
  def any_field_arguments?; end
  def argument(*args, own_argument: T.unsafe(nil), **kwargs, &block); end
  def dummy; end
  def field_arguments(context = T.unsafe(nil)); end
  def get_field_argument(name, context = T.unsafe(nil)); end
  def input_object_class(new_class = T.unsafe(nil)); end
  def input_type(new_input_type = T.unsafe(nil)); end
  def own_field_arguments; end

  private

  def generate_input_type; end
end

class GraphQL::Schema::InputObject < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Dig
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::HasValidators
  extend ::GraphQL::Schema::Member::HasValidators::ClassConfigured

  def initialize(arguments, ruby_kwargs:, context:, defaults_used:); end

  def [](key); end
  def any?(*args, **_arg1, &block); end
  def arguments; end
  def context; end
  def deconstruct_keys(keys = T.unsafe(nil)); end
  def each(*args, **_arg1, &block); end
  def empty?(*args, **_arg1, &block); end
  def key?(key); end
  def keys(*args, **_arg1, &block); end
  def map(*args, **_arg1, &block); end
  def prepare; end
  def to_h; end
  def to_hash; end
  def to_kwargs; end
  def unwrap_value(value); end
  def values(*args, **_arg1, &block); end

  private

  def overwrite_argument(key, value); end

  class << self
    def argument(*args, **kwargs, &block); end
    def arguments(context = T.unsafe(nil), require_defined_arguments = T.unsafe(nil)); end
    def authorized?(obj, value, ctx); end
    def coerce_input(value, ctx); end
    def coerce_result(value, ctx); end
    def has_no_arguments(new_has_no_arguments); end
    def has_no_arguments?; end
    def kind; end
    def one_of; end
    def one_of?; end
    def validate_non_null_input(input, ctx, max_errors: T.unsafe(nil)); end

    private

    def suppress_redefinition_warning; end
  end
end

class GraphQL::Schema::InputObject::ArgumentsAreRequiredError < ::GraphQL::Error
  def initialize(input_object_type); end
end

module GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasFields::InterfaceMethods
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::HasDataloader
  extend ::GraphQL::Schema::Member::HasDirectives
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Interface::DefinitionMethods

  def unwrap; end
end

module GraphQL::Schema::Interface::DefinitionMethods
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::EmptyObjects
  include ::GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::Member::TypeSystemHelpers
  include ::GraphQL::Schema::Member::HasFields
  include ::GraphQL::Schema::Member::HasFields::InterfaceMethods
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::RelayShortcuts
  include ::GraphQL::Schema::Member::Scoped
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasUnresolvedTypeError
  include ::GraphQL::Schema::Member::HasDataloader
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasInterfaces

  def definition_methods(&block); end
  def included(child_class); end
  def kind; end
  def orphan_types(*types); end
  def type_membership_class(membership_class = T.unsafe(nil)); end
  def visible?(context); end
end

class GraphQL::Schema::IntrospectionSystem
  def initialize(schema); end

  def dynamic_field(name:); end
  def dynamic_fields; end
  def entry_point(name:); end
  def entry_points; end
  def possible_types; end
  def resolve_late_bindings; end
  def types; end

  private

  def dup_type_class(type_class); end
  def get_fields_from_class(class_sym:); end
  def load_constant(class_name); end
  def resolve_late_binding(late_bound_type); end
end

class GraphQL::Schema::IntrospectionSystem::PerFieldProxyResolve
  def initialize(object_class:, inner_resolve:); end

  def call(obj, args, ctx); end
end

class GraphQL::Schema::InvalidDocumentError < ::GraphQL::Error; end

class GraphQL::Schema::LateBoundType
  def initialize(local_name); end

  def graphql_name; end
  def inspect; end
  def name; end
  def non_null?; end
  def to_list_type; end
  def to_non_null_type; end
  def to_s; end
  def to_type_signature; end
  def unwrap; end
end

class GraphQL::Schema::List < ::GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::ValidatesInput

  def coerce_input(value, ctx); end
  def coerce_result(value, ctx); end
  def description; end
  def graphql_name; end
  def kind; end
  def list?; end
  def to_type_signature; end
  def validate_non_null_input(value, ctx, max_errors: T.unsafe(nil)); end

  private

  def add_max_errors_reached_message(result); end
  def ensure_array(value); end
end

module GraphQL::Schema::Loader
  extend ::GraphQL::Schema::Loader

  def load(introspection_result); end

  class << self
    def build_arguments(arg_owner, args, type_resolver); end
    def build_fields(type_defn, fields, type_resolver); end

    private

    def define_directive(directive, type_resolver); end
    def define_type(type, type_resolver); end
    def extract_default_value(default_value_str, input_value_ast); end
    def resolve_type(types, type); end
  end
end

GraphQL::Schema::Loader::NullScalarCoerce = T.let(T.unsafe(nil), Proc)

class GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::BaseDSLMethods::ConfigurationExtension
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasDirectives
end

module GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::EmptyObjects

  def authorized?(object, context); end
  def comment(new_comment = T.unsafe(nil)); end
  def default_graphql_name; end
  def default_relay; end
  def description(new_description = T.unsafe(nil)); end
  def graphql_name(new_name = T.unsafe(nil)); end
  def introspection(new_introspection = T.unsafe(nil)); end
  def introspection?; end
  def mutation(mutation_class = T.unsafe(nil)); end
  def name(new_name = T.unsafe(nil)); end
  def unwrap; end
  def visible?(context); end

  protected

  def default_graphql_name=(_arg0); end
  def graphql_name=(_arg0); end
end

module GraphQL::Schema::Member::BaseDSLMethods::ConfigurationExtension
  def inherited(child_class); end
end

module GraphQL::Schema::Member::BuildType
  private

  def camelize(string); end
  def constantize(string); end
  def parse_type(type_expr, null:); end
  def to_type_name(something); end
  def underscore(string); end

  class << self
    def camelize(string); end
    def constantize(string); end
    def parse_type(type_expr, null:); end
    def to_type_name(something); end
    def underscore(string); end
  end
end

GraphQL::Schema::Member::BuildType::LIST_TYPE_ERROR = T.let(T.unsafe(nil), String)
module GraphQL::Schema::Member::GraphQLTypeNames; end
GraphQL::Schema::Member::GraphQLTypeNames::Boolean = T.let(T.unsafe(nil), String)
GraphQL::Schema::Member::GraphQLTypeNames::ID = T.let(T.unsafe(nil), String)
GraphQL::Schema::Member::GraphQLTypeNames::Int = T.let(T.unsafe(nil), String)

module GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader

  mixes_in_class_methods ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor

  def add_argument(arg_defn); end
  def all_argument_definitions; end
  def any_arguments?; end
  def argument(*args, **kwargs, &block); end
  def argument_class(new_arg_class = T.unsafe(nil)); end
  def arguments(context = T.unsafe(nil), _require_defined_arguments = T.unsafe(nil)); end
  def arguments_statically_coercible?; end
  def coerce_arguments(parent_object, values, context, &block); end
  def get_argument(argument_name, context = T.unsafe(nil)); end
  def own_arguments; end
  def remove_argument(arg_defn); end
  def validate_directive_argument(arg_defn, value); end

  class << self
    def extended(cls); end
    def included(cls); end
  end
end

module GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  def argument_class(new_arg_class = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  def authorize_application_object(argument, id, context, loaded_application_object); end
  def load_and_authorize_application_object(argument, id, context); end
  def load_application_object(argument, id, context); end
  def load_application_object_failed(err); end
  def object_from_id(type, id, context); end
end

module GraphQL::Schema::Member::HasArguments::ClassConfigured
  def inherited(child_class); end
end

module GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments
  def all_argument_definitions; end
  def any_arguments?; end
  def arguments(context = T.unsafe(nil), require_defined_arguments = T.unsafe(nil)); end
  def get_argument(argument_name, context = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasArguments::FieldConfigured
  def all_argument_definitions; end
  def any_arguments?; end
  def arguments(context = T.unsafe(nil), _require_defined_arguments = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasArguments::HasDirectiveArguments
  def validate_directive_argument(arg_defn, value); end
end

GraphQL::Schema::Member::HasArguments::NO_ARGUMENTS = T.let(T.unsafe(nil), Hash)

module GraphQL::Schema::Member::HasAstNode
  def ast_node(new_ast_node = T.unsafe(nil)); end
  def ast_node=(_arg0); end
  def inherited(child_cls); end

  class << self
    def extended(child_cls); end
  end
end

module GraphQL::Schema::Member::HasDataloader
  def dataload(source_class, *source_args, load_key); end
  def dataload_association(record = T.unsafe(nil), association_name, scope: T.unsafe(nil)); end
  def dataload_record(model, find_by_value, find_by: T.unsafe(nil)); end
  def dataloader; end
end

module GraphQL::Schema::Member::HasDeprecationReason
  def deprecation_reason; end
  def deprecation_reason=(text); end
end

module GraphQL::Schema::Member::HasDirectives
  def directive(dir_class, **options); end
  def directives; end
  def inherited(child_cls); end
  def remove_directive(dir_class); end

  protected

  def own_directives; end
  def own_directives=(_arg0); end

  class << self
    def add_directive(schema_member, directives, directive_class, directive_options); end
    def extended(child_cls); end
    def get_directives(schema_member, directives, directives_method); end
    def remove_directive(directives, directive_class); end

    private

    def merge_directives(target, dirs); end
  end
end

module GraphQL::Schema::Member::HasFields
  include ::GraphQL::Schema::Member::HasFields::InterfaceMethods

  def add_field(field_defn, method_conflict_warning: T.unsafe(nil)); end
  def all_field_definitions; end
  def field(*args, **kwargs, &block); end
  def field_class(new_field_class = T.unsafe(nil)); end
  def global_id_field(field_name, **kwargs); end
  def has_no_fields(new_has_no_fields); end
  def has_no_fields?; end
  def own_fields; end

  private

  def conflict_field_name_warning(field_defn); end
  def inherited(subclass); end
  def visible_interface_implementation?(type, context, warden); end

  class << self
    def extended(child_class); end
    def included(child_class); end
  end
end

GraphQL::Schema::Member::HasFields::CONFLICT_FIELD_NAMES = T.let(T.unsafe(nil), Set)
GraphQL::Schema::Member::HasFields::GRAPHQL_RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

module GraphQL::Schema::Member::HasFields::InterfaceMethods
  def fields(context = T.unsafe(nil)); end
  def get_field(field_name, context = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasFields::ObjectMethods
  def fields(context = T.unsafe(nil)); end
  def get_field(field_name, context = T.unsafe(nil)); end
end

GraphQL::Schema::Member::HasFields::RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

module GraphQL::Schema::Member::HasInterfaces
  def implements(*new_interfaces, **options); end
  def interface_type_memberships; end
  def interfaces(context = T.unsafe(nil)); end
  def own_interface_type_memberships; end

  private

  def inherited(subclass); end

  class << self
    def extended(child_class); end
  end
end

module GraphQL::Schema::Member::HasInterfaces::ClassConfigured
  def inherited(child_class); end
end

module GraphQL::Schema::Member::HasInterfaces::ClassConfigured::InheritedInterfaces
  def interface_type_memberships; end
  def interfaces(context = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasPath
  def path; end
end

module GraphQL::Schema::Member::HasUnresolvedTypeError
  private

  def add_unresolved_type_error(child_class); end
end

module GraphQL::Schema::Member::HasValidators
  include ::GraphQL::EmptyObjects

  def validates(validation_config); end
  def validators; end

  class << self
    def extended(child_cls); end
  end
end

module GraphQL::Schema::Member::HasValidators::ClassConfigured
  def inherited(child_cls); end
end

module GraphQL::Schema::Member::HasValidators::ClassConfigured::ClassValidators
  include ::GraphQL::EmptyObjects

  def validators; end
end

module GraphQL::Schema::Member::RelayShortcuts
  def connection_type; end
  def connection_type_class(new_connection_type_class = T.unsafe(nil)); end
  def edge_type; end
  def edge_type_class(new_edge_type_class = T.unsafe(nil)); end

  protected

  def configured_connection_type_class; end
  def configured_edge_type_class; end
  def connection_type=(_arg0); end
  def connection_type_class=(_arg0); end
  def edge_type=(_arg0); end
  def edge_type_class=(_arg0); end

  private

  def initialize_relay_metadata; end
end

module GraphQL::Schema::Member::Scoped
  def inherited(subclass); end
  def reauthorize_scoped_objects(new_value = T.unsafe(nil)); end
  def scope_items(items, context); end
end

module GraphQL::Schema::Member::TypeSystemHelpers
  def initialize(*_arg0, **_arg1, &_arg2); end

  def kind; end
  def list?; end
  def non_null?; end
  def to_list_type; end
  def to_non_null_type; end
  def to_type_signature; end

  private

  def inherited(subclass); end
end

module GraphQL::Schema::Member::ValidatesInput
  def coerce_isolated_input(v); end
  def coerce_isolated_result(v); end
  def valid_input?(val, ctx); end
  def valid_isolated_input?(v); end
  def validate_input(val, ctx, max_errors: T.unsafe(nil)); end
end

class GraphQL::Schema::Mutation < ::GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments
  extend ::GraphQL::Schema::Member::HasValidators::ClassConfigured::ClassValidators
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasFields::ObjectMethods
  extend ::GraphQL::Schema::Resolver::HasPayloadType

  def call_resolve(_args_hash); end

  class << self
    def visible?(context); end

    private

    def conflict_field_name_warning(field_defn); end
    def generate_payload_type; end
  end
end

class GraphQL::Schema::NonNull < ::GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::ValidatesInput

  def coerce_input(value, ctx); end
  def coerce_result(value, ctx); end
  def description; end
  def graphql_name; end
  def inspect; end
  def kind; end
  def list?; end
  def non_null?; end
  def to_type_signature; end
  def validate_input(value, ctx, max_errors: T.unsafe(nil)); end
end

class GraphQL::Schema::Object < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasDataloader
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasFields::ObjectMethods
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Member::HasInterfaces::ClassConfigured

  def initialize(object, context); end

  def context; end
  def dataloader; end
  def object; end
  def raw_value(obj); end

  class << self
    def authorized_new(object, context); end
    def const_missing(name); end
    def kind; end
    def scoped_new(object, context); end
    def wrap(object, context); end
    def wrap_scoped(object, context); end

    protected

    def new(*_arg0); end
  end
end

class GraphQL::Schema::Object::FieldsAreRequiredError < ::GraphQL::Error
  def initialize(object_type); end
end

class GraphQL::Schema::Printer < ::GraphQL::Language::Printer
  def initialize(schema, context: T.unsafe(nil), introspection: T.unsafe(nil)); end

  def print_schema; end
  def print_type(type); end
  def schema; end
  def warden; end

  class << self
    def print_introspection_schema; end
    def print_schema(schema, **args); end
  end
end

class GraphQL::Schema::Printer::IntrospectionPrinter < ::GraphQL::Language::Printer
  def print_schema_definition(schema); end
end

class GraphQL::Schema::RelayClassicMutation < ::GraphQL::Schema::Mutation
  include ::GraphQL::Schema::HasSingleInputArgument
  extend ::GraphQL::Schema::HasSingleInputArgument::ClassMethods

  def resolve_with_support(**inputs); end
end

class GraphQL::Schema::Resolver
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasDataloader
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::BaseDSLMethods::ConfigurationExtension
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured
  extend ::GraphQL::Schema::Member::HasValidators
  extend ::GraphQL::Schema::Member::HasValidators::ClassConfigured
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::HasDirectives

  def initialize(object:, context:, field:); end

  def arguments; end
  def authorized?(**inputs); end
  def call_resolve(args_hash); end
  def context; end
  def field; end
  def object; end
  def ready?(**args); end
  def resolve(**args); end
  def resolve_with_support(**args); end
  def unauthorized_object(err); end

  private

  def authorize_arguments(args, inputs); end
  def get_argument(name, context = T.unsafe(nil)); end
  def load_arguments(args); end

  class << self
    def all_field_argument_definitions; end
    def any_field_arguments?; end
    def argument(*args, **kwargs, &block); end
    def broadcastable(new_broadcastable); end
    def broadcastable?; end
    def complexity(new_complexity = T.unsafe(nil)); end
    def default_page_size(new_default_page_size = T.unsafe(nil)); end
    def extension(extension, **options); end
    def extensions; end
    def extras(new_extras = T.unsafe(nil)); end
    def field_arguments(context = T.unsafe(nil)); end
    def get_field_argument(name, context = T.unsafe(nil)); end
    def has_default_page_size?; end
    def has_max_page_size?; end
    def max_page_size(new_max_page_size = T.unsafe(nil)); end
    def null(allow_null = T.unsafe(nil)); end
    def resolve_method(new_method = T.unsafe(nil)); end
    def resolver_method(new_method_name = T.unsafe(nil)); end
    def type(new_type = T.unsafe(nil), null: T.unsafe(nil)); end
    def type_expr; end

    private

    def own_extensions; end
  end
end

module GraphQL::Schema::Resolver::HasPayloadType
  def field(*args, **kwargs, &block); end
  def field_class(new_class = T.unsafe(nil)); end
  def object_class(new_class = T.unsafe(nil)); end
  def payload_type(new_payload_type = T.unsafe(nil)); end
  def type(new_type = T.unsafe(nil), null: T.unsafe(nil)); end
  def type_expr(new_payload_type = T.unsafe(nil)); end

  private

  def generate_payload_type; end
end

GraphQL::Schema::Resolver::HasPayloadType::NO_INTERFACES = T.let(T.unsafe(nil), Array)

class GraphQL::Schema::Scalar < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::ValidatesInput

  class << self
    def coerce_input(val, ctx); end
    def coerce_result(val, ctx); end
    def default_scalar(is_default = T.unsafe(nil)); end
    def default_scalar?; end
    def kind; end
    def specified_by_url(new_url = T.unsafe(nil)); end
    def validate_non_null_input(value, ctx, max_errors: T.unsafe(nil)); end
  end
end

module GraphQL::Schema::SubclassGetReferencesTo
  def get_references_to(type_defn); end
end

class GraphQL::Schema::Subscription < ::GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Member::HasArguments::ClassConfigured::InheritedArguments
  extend ::GraphQL::Schema::Member::HasValidators::ClassConfigured::ClassValidators
  extend ::GraphQL::Schema::Resolver::HasPayloadType
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasFields::ObjectMethods

  def initialize(object:, context:, field:); end

  def event; end
  def load_application_object_failed(err); end
  def resolve(**args); end
  def resolve_subscribe(**args); end
  def resolve_update(**args); end
  def resolve_with_support(**args); end
  def subscribe(args = T.unsafe(nil)); end
  def subscription_written?; end
  def unsubscribe(update_value = T.unsafe(nil)); end
  def update(args = T.unsafe(nil)); end
  def write_subscription; end

  class << self
    def subscription_scope(new_scope = T.unsafe(nil), optional: T.unsafe(nil)); end
    def subscription_scope_optional?; end
    def topic_for(arguments:, field:, scope:); end
  end
end

GraphQL::Schema::Subscription::NO_UPDATE = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Timeout
  def initialize(max_seconds:); end

  def handle_timeout(error, query); end
  def max_seconds(query); end

  class << self
    def use(schema, max_seconds: T.unsafe(nil)); end
  end
end

class GraphQL::Schema::Timeout::TimeoutError < ::GraphQL::ExecutionError
  def initialize(field); end
end

module GraphQL::Schema::Timeout::Trace
  def initialize(timeout:, **rest); end

  def execute_field(query:, field:, **_rest); end
  def execute_multiplex(multiplex:); end
end

module GraphQL::Schema::TypeExpression
  class << self
    def build_type(type_owner, ast_node); end

    private

    def wrap_type(type, wrapper_method); end
  end
end

class GraphQL::Schema::TypeMembership
  def initialize(abstract_type, object_type, **options); end

  def abstract_type; end
  def graphql_name; end
  def inspect; end
  def object_type; end
  def object_type=(_arg0); end
  def options; end
  def path; end
  def type_class; end
  def visible?(ctx); end
end

class GraphQL::Schema::Union < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError

  class << self
    def all_possible_types; end
    def assign_type_membership_object_type(object_type); end
    def inherited(child_class); end
    def kind; end
    def possible_types(*types, context: T.unsafe(nil), **options); end
    def type_membership_class(membership_class = T.unsafe(nil)); end
    def type_memberships; end

    private

    def assert_valid_union_member(type_defn); end
  end
end

module GraphQL::Schema::UniqueWithinType
  private

  def decode(node_id, separator: T.unsafe(nil)); end
  def encode(type_name, object_value, separator: T.unsafe(nil)); end

  class << self
    def decode(node_id, separator: T.unsafe(nil)); end
    def default_id_separator; end
    def default_id_separator=(_arg0); end
    def encode(type_name, object_value, separator: T.unsafe(nil)); end
  end
end

class GraphQL::Schema::UnresolvedLateBoundTypeError < ::GraphQL::Error
  def initialize(type:); end

  def type; end
end

class GraphQL::Schema::Validator
  include ::GraphQL::EmptyObjects

  def initialize(validated:, allow_blank: T.unsafe(nil), allow_null: T.unsafe(nil)); end

  def partial_format(string, substitutions); end
  def permitted_empty_value?(value); end
  def validate(object, context, value); end
  def validated; end

  class << self
    def all_validators; end
    def all_validators=(_arg0); end
    def from_config(schema_member, validates_hash); end
    def install(name, validator_class); end
    def uninstall(name); end
    def validate!(validators, object, context, value, as: T.unsafe(nil)); end
  end
end

class GraphQL::Schema::Validator::AllValidator < ::GraphQL::Schema::Validator
  def initialize(validated:, allow_blank: T.unsafe(nil), allow_null: T.unsafe(nil), **validators); end

  def validate(object, context, value); end
end

class GraphQL::Schema::Validator::AllowBlankValidator < ::GraphQL::Schema::Validator
  def initialize(allow_blank_positional, allow_blank: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

class GraphQL::Schema::Validator::AllowNullValidator < ::GraphQL::Schema::Validator
  def initialize(allow_null_positional, allow_null: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

GraphQL::Schema::Validator::AllowNullValidator::MESSAGE = T.let(T.unsafe(nil), String)

class GraphQL::Schema::Validator::ExclusionValidator < ::GraphQL::Schema::Validator
  def initialize(in:, message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

class GraphQL::Schema::Validator::FormatValidator < ::GraphQL::Schema::Validator
  def initialize(with: T.unsafe(nil), without: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

class GraphQL::Schema::Validator::InclusionValidator < ::GraphQL::Schema::Validator
  def initialize(in:, message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

class GraphQL::Schema::Validator::LengthValidator < ::GraphQL::Schema::Validator
  def initialize(maximum: T.unsafe(nil), too_long: T.unsafe(nil), minimum: T.unsafe(nil), too_short: T.unsafe(nil), is: T.unsafe(nil), within: T.unsafe(nil), wrong_length: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

class GraphQL::Schema::Validator::NumericalityValidator < ::GraphQL::Schema::Validator
  def initialize(greater_than: T.unsafe(nil), greater_than_or_equal_to: T.unsafe(nil), less_than: T.unsafe(nil), less_than_or_equal_to: T.unsafe(nil), equal_to: T.unsafe(nil), other_than: T.unsafe(nil), odd: T.unsafe(nil), even: T.unsafe(nil), within: T.unsafe(nil), message: T.unsafe(nil), null_message: T.unsafe(nil), **default_options); end

  def validate(object, context, value); end
end

class GraphQL::Schema::Validator::RequiredValidator < ::GraphQL::Schema::Validator
  def initialize(one_of: T.unsafe(nil), argument: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def arg_keyword_to_grapqhl_name(argument_definitions, arg_keyword); end
  def build_message(context); end
  def validate(_object, context, value); end
end

class GraphQL::Schema::Validator::ValidationFailedError < ::GraphQL::ExecutionError
  def initialize(errors:); end

  def errors; end
end

class GraphQL::Schema::Visibility
  def initialize(schema, dynamic:, preload:, profiles:, migration_errors:); end

  def all_directives; end
  def all_interface_type_memberships; end
  def all_references; end
  def cached_profiles; end
  def dup_for(other_schema); end
  def get_type(type_name); end
  def introspection_system_configured(introspection_system); end
  def migration_errors?; end
  def mutation_configured(mutation_type); end
  def orphan_types_configured(orphan_types); end
  def preload; end
  def preload?; end
  def profile_for(context, visibility_profile = T.unsafe(nil)); end
  def query_configured(query_type); end
  def subscription_configured(subscription_type); end
  def top_level; end
  def top_level_profile(refresh: T.unsafe(nil)); end
  def unfiltered_interface_type_memberships; end

  private

  def ensure_all_loaded(types_to_visit); end
  def load_all(types: T.unsafe(nil)); end

  class << self
    def use(schema, dynamic: T.unsafe(nil), profiles: T.unsafe(nil), preload: T.unsafe(nil), migration_errors: T.unsafe(nil)); end
  end
end

class GraphQL::Schema::Visibility::Migration < ::GraphQL::Schema::Visibility::Profile
  def initialize(context:, schema:, name: T.unsafe(nil)); end

  def all_types(*args); end
  def all_types_h(*args); end
  def argument(*args); end
  def arguments(*args); end
  def call_method_and_compare(method, args); end
  def directive_exists?(*args); end
  def directives(*args); end
  def enum_values(*args); end
  def equivalent_schema_members?(member1, member2); end
  def field(*args); end
  def fields(*args); end
  def interfaces(*args); end
  def loadable?(*args); end
  def loadable_possible_types(*args); end
  def loaded_types; end
  def mutation_root(*args); end
  def possible_types(*args); end
  def query_root(*args); end
  def reachable_type?(*args); end
  def subscription_root(*args); end
  def type(*args); end
  def visible_enum_value?(*args); end
end

GraphQL::Schema::Visibility::Migration::PUBLIC_PROFILE_METHODS = T.let(T.unsafe(nil), Array)

class GraphQL::Schema::Visibility::Migration::RuntimeTypesMismatchError < ::GraphQL::Error
  def initialize(method_called, warden_result, profile_result, method_args); end

  private

  def compare_results(warden_result, profile_result); end
  def humanize(val); end
end

class GraphQL::Schema::Visibility::Profile
  def initialize(context:, schema:, name: T.unsafe(nil)); end

  def all_types; end
  def all_types_h; end
  def argument(owner, arg_name); end
  def arguments(owner); end
  def directive_exists?(dir_name); end
  def directives; end
  def enum_values(owner); end
  def field(owner, field_name); end
  def field_on_visible_interface?(field, owner); end
  def fields(owner); end
  def interfaces(obj_or_int_type); end
  def loadable?(t, _ctx); end
  def loadable_possible_types(t, _ctx); end
  def loaded_types; end
  def mutation_root; end
  def name; end
  def possible_types(type); end
  def query_root; end
  def reachable_type?(type_name); end
  def subscription_root; end
  def type(type_name); end
  def visible_enum_value?(enum_value, _ctx = T.unsafe(nil)); end

  private

  def load_all_types; end
  def non_duplicate_items(definitions, visibility_cache); end
  def possible_types_for(type); end
  def raise_duplicate_definition(first_defn, second_defn); end
  def referenced?(type_defn); end
  def visible_field_for(owner, field); end

  class << self
    def from_context(ctx, schema); end
    def null_profile(context:, schema:); end
  end
end

class GraphQL::Schema::Visibility::Visit
  def initialize(schema, &visit_block); end

  def entry_point_directives; end
  def entry_point_types; end
  def visit_each(types: T.unsafe(nil), directives: T.unsafe(nil)); end

  private

  def append_unvisited_type(owner, type); end
  def update_type_owner(owner, type); end
end

class GraphQL::Schema::Warden
  def initialize(context:, schema:); end

  def arguments(argument_owner, ctx = T.unsafe(nil)); end
  def directives; end
  def enum_values(enum_defn); end
  def fields(type_defn); end
  def get_argument(parent_type, argument_name); end
  def get_field(parent_type, field_name); end
  def get_type(type_name); end
  def interface_type_memberships(obj_type, _ctx = T.unsafe(nil)); end
  def interfaces(obj_type); end
  def loadable?(type, _ctx); end
  def loadable_possible_types(union_type, _ctx); end
  def possible_types(type_defn); end
  def reachable_type?(type_name); end
  def reachable_types; end
  def root_type_for_operation(op_name); end
  def skip_warning=(_arg0); end
  def types; end
  def visibility_profile; end
  def visible_argument?(arg_defn, _ctx = T.unsafe(nil)); end
  def visible_enum_value?(enum_value, _ctx = T.unsafe(nil)); end
  def visible_field?(field_defn, _ctx = T.unsafe(nil), owner = T.unsafe(nil)); end
  def visible_type?(type_defn, _ctx = T.unsafe(nil)); end
  def visible_type_membership?(type_membership, _ctx = T.unsafe(nil)); end

  private

  def check_visible(schema, member); end
  def field_on_visible_interface?(field_defn, type_defn); end
  def orphan_type?(type_defn); end
  def reachable_type_set; end
  def read_through; end
  def referenced?(type_defn); end
  def root_type?(type_defn); end
  def unfiltered_interfaces(type_defn); end
  def union_memberships(obj_type); end
  def visible?(member); end
  def visible_and_reachable_type?(type_defn); end
  def visit_type(type, unvisited_types, visited_type_set, type_by_name_hash, included_interface_possible_types_set, include_interface_possible_types:); end

  class << self
    def from_context(context); end
    def types_from_context(context); end
    def use(schema); end
    def visible_entry?(visibility_method, entry, context, warden = T.unsafe(nil)); end
  end
end

GraphQL::Schema::Warden::ADD_WARDEN_WARNING = T.let(T.unsafe(nil), String)

class GraphQL::Schema::Warden::NullWarden
  def initialize(_filter = T.unsafe(nil), context:, schema:); end

  def arguments(argument_owner, ctx = T.unsafe(nil)); end
  def directives; end
  def enum_values(enum_defn); end
  def fields(type_defn); end
  def get_argument(parent_type, argument_name); end
  def get_field(parent_type, field_name); end
  def get_type(type_name); end
  def interface_type_memberships(obj_type, _ctx = T.unsafe(nil)); end
  def interfaces(obj_type); end
  def loadable?(type, _ctx); end
  def loadable_possible_types(union_type, _ctx); end
  def possible_types(type_defn); end
  def reachable_type?(type_name); end
  def reachable_types; end
  def root_type_for_operation(op_name); end
  def skip_warning=(_arg0); end
  def types; end
  def visibility_profile; end
  def visible_argument?(arg_defn, _ctx = T.unsafe(nil)); end
  def visible_enum_value?(enum_value, _ctx = T.unsafe(nil)); end
  def visible_field?(field_defn, _ctx = T.unsafe(nil), owner = T.unsafe(nil)); end
  def visible_type?(type_defn, _ctx = T.unsafe(nil)); end
  def visible_type_membership?(type_membership, _ctx = T.unsafe(nil)); end
end

class GraphQL::Schema::Warden::PassThruWarden
  class << self
    def arguments(owner, ctx); end
    def interface_type_memberships(obj_t, ctx); end
    def loadable?(type, ctx); end
    def loadable_possible_types(type, ctx); end
    def visibility_profile; end
    def visible_argument?(arg, ctx); end
    def visible_enum_value?(ev, ctx); end
    def visible_field?(field, ctx); end
    def visible_type?(type, ctx); end
    def visible_type_membership?(tm, ctx); end
  end
end

class GraphQL::Schema::Warden::VisibilityProfile
  def initialize(warden); end

  def all_types; end
  def argument(owner, arg_name); end
  def arguments(owner); end
  def directive_exists?(dir_name); end
  def directives; end
  def enum_values(enum_type); end
  def field(owner, field_name); end
  def fields(owner); end
  def interfaces(obj_type); end
  def loadable?(t, ctx); end
  def loadable_possible_types(t, ctx); end
  def mutation_root; end
  def possible_types(type); end
  def query_root; end
  def reachable_type?(type_name); end
  def subscription_root; end
  def type(name); end
  def visible_enum_value?(enum_value, ctx = T.unsafe(nil)); end
end

class GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::TypeSystemHelpers

  def initialize(of_type); end

  def ==(other); end
  def of_type; end
  def unwrap; end
end

module GraphQL::StaticValidation; end
GraphQL::StaticValidation::ALL_RULES = T.let(T.unsafe(nil), Array)

module GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  def on_argument(node, parent); end
end

class GraphQL::StaticValidation::ArgumentLiteralsAreCompatibleError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil), argument_name: T.unsafe(nil), extensions: T.unsafe(nil), coerce_extensions: T.unsafe(nil), argument: T.unsafe(nil), value: T.unsafe(nil)); end

  def argument; end
  def argument_name; end
  def code; end
  def to_h; end
  def type_name; end
  def value; end
end

module GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def on_directive(node, parent); end
  def on_field(node, parent); end
  def validate_arguments(node); end
end

class GraphQL::StaticValidation::ArgumentNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def name; end
  def to_h; end
end

module GraphQL::StaticValidation::ArgumentsAreDefined
  def on_argument(node, parent); end

  private

  def node_type(parent); end
  def parent_definition(parent); end
  def parent_name(parent, type_defn); end
end

class GraphQL::StaticValidation::ArgumentsAreDefinedError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, type:, argument_name:, parent:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def argument_name; end
  def code; end
  def name; end
  def parent; end
  def to_h; end
  def type_name; end
end

class GraphQL::StaticValidation::BaseVisitor < ::GraphQL::Language::StaticVisitor
  def initialize(document, context); end

  def context; end
  def object_types; end
  def path; end

  private

  def add_error(error, path: T.unsafe(nil)); end

  class << self
    def including_rules(rules); end
  end
end

module GraphQL::StaticValidation::BaseVisitor::ContextMethods
  def argument_definition; end
  def directive_definition; end
  def field_definition; end
  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object(node, parent); end
  def on_operation_definition(node, parent); end
  def parent_type_definition; end
  def type_definition; end

  private

  def on_fragment_with_type(node); end
  def push_type(t); end
end

module GraphQL::StaticValidation::DefinitionDependencies
  def initialize(*_arg0); end

  def dependencies; end
  def dependency_map(&block); end
  def on_document(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_operation_definition(node, prev_node); end

  private

  def resolve_dependencies; end
end

class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
  def initialize; end

  def [](definition_node); end
  def cyclical_definitions; end
  def unmet_dependencies; end
  def unused_dependencies; end
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  extend ::Forwardable

  def initialize(node, path); end

  def eql?(*args, **_arg1, &block); end
  def hash(*args, **_arg1, &block); end
  def name(*args, **_arg1, &block); end
  def node; end
  def path; end
end

module GraphQL::StaticValidation::DirectivesAreDefined
  def initialize(*_arg0); end

  def on_directive(node, parent); end
end

class GraphQL::StaticValidation::DirectivesAreDefinedError < ::GraphQL::StaticValidation::Error
  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def directive_name; end
  def to_h; end
end

module GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::Language

  def on_directive(node, parent); end

  private

  def assert_includes_location(directive_defn, directive_ast, required_location); end
  def validate_location(ast_directive, ast_parent, directives); end
end

GraphQL::StaticValidation::DirectivesAreInValidLocations::LOCATION_MESSAGE_NAMES = T.let(T.unsafe(nil), Hash)
GraphQL::StaticValidation::DirectivesAreInValidLocations::SIMPLE_LOCATIONS = T.let(T.unsafe(nil), Hash)
GraphQL::StaticValidation::DirectivesAreInValidLocations::SIMPLE_LOCATION_NODES = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::DirectivesAreInValidLocationsError < ::GraphQL::StaticValidation::Error
  def initialize(message, target:, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def code; end
  def name; end
  def target_name; end
  def to_h; end
end

class GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def message; end
  def nodes; end
  def path; end
  def path=(_arg0); end
  def to_h; end

  private

  def locations; end
end

module GraphQL::StaticValidation::Error::ErrorHelper
  def error(error_message, nodes, context: T.unsafe(nil), path: T.unsafe(nil), extensions: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::FieldsAreDefinedOnType
  def on_field(node, parent); end

  private

  def possible_fields(context, parent_type); end
end

class GraphQL::StaticValidation::FieldsAreDefinedOnTypeError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, field:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def field_name; end
  def to_h; end
  def type_name; end
end

module GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def on_field(node, parent); end
  def on_operation_definition(node, _parent); end

  private

  def validate_field_selections(ast_node, resolved_type); end
end

class GraphQL::StaticValidation::FieldsHaveAppropriateSelectionsError < ::GraphQL::StaticValidation::Error
  def initialize(message, node_name:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def code; end
  def node_name; end
  def to_h; end
  def type_name; end
end

module GraphQL::StaticValidation::FieldsWillMerge
  def initialize(*_arg0); end

  def on_field(node, _parent); end
  def on_operation_definition(node, _parent); end

  private

  def arg_conflicts; end
  def compared_fragments_key(frag1, frag2, exclusive); end
  def conflicts_within_selection_set(node, parent_type); end
  def field_conflicts; end
  def fields_and_fragments_from_selection(node, owner_type:, parents:); end
  def find_conflict(response_key, field1, field2, mutually_exclusive: T.unsafe(nil)); end
  def find_conflicts_between(response_keys, response_keys2, mutually_exclusive:); end
  def find_conflicts_between_fields_and_fragment(fragment_spread, fields, mutually_exclusive:); end
  def find_conflicts_between_fragments(fragment_spread1, fragment_spread2, mutually_exclusive:); end
  def find_conflicts_between_sub_selection_sets(field1, field2, mutually_exclusive:); end
  def find_conflicts_within(response_keys); end
  def find_fields_and_fragments(selections, owner_type:, parents:, fields:, fragment_spreads:); end
  def mutually_exclusive?(parents1, parents2); end
  def same_arguments?(field1, field2); end
  def serialize_arg(arg_value); end
  def serialize_field_args(field); end
  def setting_errors; end
end

class GraphQL::StaticValidation::FieldsWillMerge::Field < ::Struct
  def definition; end
  def definition=(_); end
  def node; end
  def node=(_); end
  def owner_type; end
  def owner_type=(_); end
  def parents; end
  def parents=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread < ::Struct
  def name; end
  def name=(_); end
  def parents; end
  def parents=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

GraphQL::StaticValidation::FieldsWillMerge::NO_ARGS = T.let(T.unsafe(nil), Hash)
GraphQL::StaticValidation::FieldsWillMerge::NO_SELECTIONS = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::FieldsWillMergeError < ::GraphQL::StaticValidation::Error
  def initialize(kind:, field_name:); end

  def add_conflict(node, conflict_str); end
  def code; end
  def conflicts; end
  def field_name; end
  def kind; end
  def message; end
  def path; end
  def to_h; end
end

module GraphQL::StaticValidation::FragmentNamesAreUnique
  def initialize(*_arg0); end

  def on_document(_n, _p); end
  def on_fragment_definition(node, parent); end
end

class GraphQL::StaticValidation::FragmentNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def fragment_name; end
  def to_h; end
end

module GraphQL::StaticValidation::FragmentSpreadsArePossible
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end

  private

  def validate_fragment_in_scope(parent_type, child_type, node, context, path); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
  def initialize(node:, parent_type:, path:); end

  def node; end
  def parent_type; end
  def path; end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossibleError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, fragment_name:, parent:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def fragment_name; end
  def parent_name; end
  def to_h; end
  def type_name; end
end

module GraphQL::StaticValidation::FragmentTypesExist
  def on_fragment_definition(node, _parent); end
  def on_inline_fragment(node, _parent); end

  private

  def validate_type_exists(fragment_node); end
end

class GraphQL::StaticValidation::FragmentTypesExistError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def to_h; end
  def type_name; end
end

module GraphQL::StaticValidation::FragmentsAreFinite
  def on_document(_n, _p); end
end

class GraphQL::StaticValidation::FragmentsAreFiniteError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def fragment_name; end
  def to_h; end
end

module GraphQL::StaticValidation::FragmentsAreNamed
  def on_fragment_definition(node, _parent); end
end

class GraphQL::StaticValidation::FragmentsAreNamedError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def to_h; end
end

module GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  def on_fragment_definition(node, parent); end
  def on_inline_fragment(node, parent); end

  private

  def validate_type_is_composite(node); end
end

class GraphQL::StaticValidation::FragmentsAreOnCompositeTypesError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def argument_name; end
  def code; end
  def to_h; end
  def type_name; end
end

module GraphQL::StaticValidation::FragmentsAreUsed
  def on_document(node, parent); end
end

class GraphQL::StaticValidation::FragmentsAreUsedError < ::GraphQL::StaticValidation::Error
  def initialize(message, fragment:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def fragment_name; end
  def to_h; end
end

module GraphQL::StaticValidation::InputObjectNamesAreUnique
  def on_input_object(node, parent); end

  private

  def validate_input_fields(node); end
end

class GraphQL::StaticValidation::InputObjectNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def name; end
  def to_h; end
end

class GraphQL::StaticValidation::InterpreterVisitor < ::GraphQL::StaticValidation::BaseVisitor
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::OneOfInputObjectsAreValid
  include ::GraphQL::StaticValidation::InputObjectNamesAreUnique
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::QueryRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

class GraphQL::StaticValidation::LiteralValidator
  def initialize(context:); end

  def validate(ast_value, type); end

  private

  def constant_scalar?(ast_value); end
  def ensure_array(value); end
  def maybe_raise_if_invalid(ast_value); end
  def merge_results(results_list); end
  def present_input_field_values_are_valid(type, ast_node); end
  def recursively_validate(ast_value, type); end
  def replace_nulls_in(ast_value); end
  def required_input_fields_are_present(type, ast_node); end
end

module GraphQL::StaticValidation::MutationRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::MutationRootExistsError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def to_h; end
end

module GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def initialize(*_arg0); end

  def on_directive_definition(node, parent); end
  def on_document(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_invalid_node(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_extension(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_extension(node, parent); end
end

class GraphQL::StaticValidation::NoDefinitionsArePresentError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def to_h; end
end

module GraphQL::StaticValidation::OneOfInputObjectsAreValid
  def on_input_object(node, parent); end

  private

  def validate_one_of_input_object(ast_node, context, parent_type); end
end

class GraphQL::StaticValidation::OneOfInputObjectsAreValidError < ::GraphQL::StaticValidation::Error
  def initialize(message, path:, nodes:, input_object_type:); end

  def code; end
  def input_object_type; end
  def to_h; end
end

module GraphQL::StaticValidation::OperationNamesAreValid
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_operation_definition(node, parent); end
end

class GraphQL::StaticValidation::OperationNamesAreValidError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def code; end
  def operation_name; end
  def to_h; end
end

module GraphQL::StaticValidation::QueryRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::QueryRootExistsError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def to_h; end
end

module GraphQL::StaticValidation::RequiredArgumentsArePresent
  def on_directive(node, _parent); end
  def on_field(node, _parent); end

  private

  def assert_required_args(ast_node, defn); end
end

class GraphQL::StaticValidation::RequiredArgumentsArePresentError < ::GraphQL::StaticValidation::Error
  def initialize(message, class_name:, name:, arguments:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def arguments; end
  def class_name; end
  def code; end
  def name; end
  def to_h; end
end

module GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  def on_input_object(node, parent); end

  private

  def get_parent_type(context, parent); end
  def validate_input_object(ast_node, context, parent); end
end

class GraphQL::StaticValidation::RequiredInputObjectAttributesArePresentError < ::GraphQL::StaticValidation::Error
  def initialize(message, path:, nodes:, argument_type:, argument_name:, input_object_type:); end

  def argument_name; end
  def argument_type; end
  def code; end
  def input_object_type; end
  def to_h; end
end

module GraphQL::StaticValidation::SubscriptionRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::SubscriptionRootExistsError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def to_h; end
end

module GraphQL::StaticValidation::UniqueDirectivesPerLocation
  def on_enum_type_definition(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_field(node, parent); end
  def on_field_definition(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_operation_definition(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_union_type_definition(node, parent); end

  private

  def validate_directive_location(node); end
end

GraphQL::StaticValidation::UniqueDirectivesPerLocation::DIRECTIVE_NODE_HOOKS = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::UniqueDirectivesPerLocationError < ::GraphQL::StaticValidation::Error
  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def directive_name; end
  def to_h; end
end

class GraphQL::StaticValidation::ValidationContext
  extend ::Forwardable

  def initialize(query, visitor_class, max_errors); end

  def argument_definition(*args, **_arg1, &block); end
  def dependencies(*args, **_arg1, &block); end
  def did_you_mean_suggestion(name, options); end
  def directive_definition(*args, **_arg1, &block); end
  def document(*args, **_arg1, &block); end
  def errors; end
  def field_definition(*args, **_arg1, &block); end
  def fragments(*args, **_arg1, &block); end
  def max_errors; end
  def object_types(*args, **_arg1, &block); end
  def on_dependency_resolve(&handler); end
  def on_dependency_resolve_handlers; end
  def operations(*args, **_arg1, &block); end
  def parent_type_definition(*args, **_arg1, &block); end
  def path(*args, **_arg1, &block); end
  def query; end
  def schema; end
  def schema_directives; end
  def too_many_errors?; end
  def type_definition(*args, **_arg1, &block); end
  def types; end
  def validate_literal(ast_value, type); end
  def visitor; end
end

class GraphQL::StaticValidation::ValidationTimeoutError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def to_h; end
end

class GraphQL::StaticValidation::Validator
  def initialize(schema:, rules: T.unsafe(nil)); end

  def handle_timeout(query, context); end
  def validate(query, validate: T.unsafe(nil), timeout: T.unsafe(nil), max_errors: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  def on_variable_definition(node, parent); end
end

class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def code; end
  def to_h; end
  def type_name; end
  def variable_name; end
  def violation; end
end

GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError::VIOLATIONS = T.let(T.unsafe(nil), Hash)

module GraphQL::StaticValidation::VariableNamesAreUnique
  def on_operation_definition(node, parent); end
end

class GraphQL::StaticValidation::VariableNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def to_h; end
  def variable_name; end
end

module GraphQL::StaticValidation::VariableUsagesAreAllowed
  def initialize(*_arg0); end

  def on_argument(node, parent); end
  def on_operation_definition(node, parent); end

  private

  def create_error(error_message, var_type, ast_var, arg_defn, arg_node); end
  def depth_of_array(array); end
  def list_dimension(type); end
  def non_null_levels_match(arg_type, var_type); end
  def validate_usage(argument_owner, arg_node, ast_var); end
  def wrap_var_type_with_depth_of_arg(var_type, arg_node); end
end

class GraphQL::StaticValidation::VariableUsagesAreAllowedError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, name:, argument:, error:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def argument_name; end
  def code; end
  def error_message; end
  def to_h; end
  def type_name; end
  def variable_name; end
end

module GraphQL::StaticValidation::VariablesAreInputTypes
  def on_variable_definition(node, parent); end

  private

  def get_type_name(ast_type); end
end

class GraphQL::StaticValidation::VariablesAreInputTypesError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def to_h; end
  def type_name; end
  def variable_name; end
end

module GraphQL::StaticValidation::VariablesAreUsedAndDefined
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_operation_definition(node, parent); end
  def on_variable_identifier(node, parent); end

  private

  def create_errors(node_variables); end
  def follow_spreads(node, parent_variables, spreads_for_context, fragment_definitions, visited_fragments); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
  def ast_node; end
  def ast_node=(_arg0); end
  def declared?; end
  def declared_by; end
  def declared_by=(_arg0); end
  def path; end
  def path=(_arg0); end
  def used?; end
  def used_by; end
  def used_by=(_arg0); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefinedError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end
  def to_h; end
  def variable_name; end
  def violation; end
end

GraphQL::StaticValidation::VariablesAreUsedAndDefinedError::VIOLATIONS = T.let(T.unsafe(nil), Hash)

class GraphQL::StringEncodingError < ::GraphQL::RuntimeTypeError
  def initialize(str, context:); end

  def field; end
  def path; end
  def string; end
end

class GraphQL::Subscriptions
  def initialize(schema:, validate_update: T.unsafe(nil), broadcast: T.unsafe(nil), default_broadcastable: T.unsafe(nil), **rest); end

  def broadcastable?(query_str, **query_options); end
  def build_id; end
  def default_broadcastable; end
  def delete_subscription(subscription_id); end
  def deliver(subscription_id, result); end
  def execute(subscription_id, event, object); end
  def execute_all(event, object); end
  def execute_update(subscription_id, event, object); end
  def normalize_name(event_or_arg_name); end
  def read_subscription(subscription_id); end
  def trigger(event_name, args, object, scope: T.unsafe(nil), context: T.unsafe(nil)); end
  def validate_update?(query:, context:, root_value:, subscription_topic:, operation_name:, variables:); end
  def write_subscription(query, events); end

  private

  def normalize_arguments(event_name, arg_owner, args, context); end

  class << self
    def use(defn, options = T.unsafe(nil)); end
  end
end

class GraphQL::Subscriptions::ActionCableSubscriptions < ::GraphQL::Subscriptions
  def initialize(serializer: T.unsafe(nil), namespace: T.unsafe(nil), action_cable: T.unsafe(nil), action_cable_coder: T.unsafe(nil), **rest); end

  def delete_subscription(subscription_id); end
  def deliver(subscription_id, result); end
  def execute_all(event, object); end
  def load_action_cable_message(message, context); end
  def read_subscription(subscription_id); end
  def setup_stream(channel, initial_event); end
  def write_subscription(query, events); end

  private

  def stream_event_name(event); end
  def stream_subscription_name(subscription_id); end
end

GraphQL::Subscriptions::ActionCableSubscriptions::EVENT_PREFIX = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::ActionCableSubscriptions::SUBSCRIPTION_PREFIX = T.let(T.unsafe(nil), String)

class GraphQL::Subscriptions::BroadcastAnalyzer < ::GraphQL::Analysis::Analyzer
  def initialize(subject); end

  def analyze?; end
  def on_enter_field(node, parent, visitor); end
  def result; end

  private

  def apply_broadcastable(owner_type, field_defn); end
end

class GraphQL::Subscriptions::DefaultSubscriptionResolveExtension < ::GraphQL::Schema::FieldExtension
  def after_resolve(value:, context:, object:, arguments:, **rest); end
  def resolve(context:, object:, arguments:); end
end

class GraphQL::Subscriptions::Event
  def initialize(name:, arguments:, field: T.unsafe(nil), context: T.unsafe(nil), scope: T.unsafe(nil)); end

  def arguments; end
  def context; end
  def fingerprint; end
  def name; end
  def topic; end

  class << self
    def arguments_without_field_extras(arguments:, field:); end
    def serialize(_name, arguments, field, scope:, context: T.unsafe(nil)); end

    private

    def deep_sort_array_hashes(array_to_inspect); end
    def deep_sort_hash_keys(hash_to_sort); end
    def get_arg_definition(arg_owner, arg_name, context); end
    def stringify_args(arg_owner, args, context); end
  end
end

class GraphQL::Subscriptions::InvalidTriggerError < ::GraphQL::Error; end

module GraphQL::Subscriptions::Serialize
  private

  def dump(obj); end
  def dump_recursive(obj); end
  def load(str); end

  class << self
    def dump(obj); end
    def dump_recursive(obj); end
    def load(str); end

    private

    def dump_value(obj); end
    def load_value(value); end
  end
end

GraphQL::Subscriptions::Serialize::GLOBALID_KEY = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::Serialize::OPEN_STRUCT_KEY = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::Serialize::SYMBOL_KEY = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::Serialize::SYMBOL_KEYS_KEY = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::Serialize::TIMESTAMP_FORMAT = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::Serialize::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)
class GraphQL::Subscriptions::SubscriptionScopeMissingError < ::GraphQL::Error; end
module GraphQL::Testing; end

module GraphQL::Testing::Helpers
  def run_graphql_field(schema, field_path, object, arguments: T.unsafe(nil), context: T.unsafe(nil), ast_node: T.unsafe(nil), lookahead: T.unsafe(nil)); end
  def with_resolution_context(schema, type:, object:, context: T.unsafe(nil)); end

  class << self
    def for(schema_class); end
  end
end

class GraphQL::Testing::Helpers::Error < ::GraphQL::Error; end

class GraphQL::Testing::Helpers::FieldNotDefinedError < ::GraphQL::Testing::Helpers::Error
  def initialize(type_name:, field_name:); end
end

class GraphQL::Testing::Helpers::FieldNotVisibleError < ::GraphQL::Testing::Helpers::Error
  def initialize(type_name:, field_name:); end
end

class GraphQL::Testing::Helpers::ResolutionAssertionContext
  def initialize(test, type_name:, object:, schema:, context:); end

  def run_graphql_field(field_name, arguments: T.unsafe(nil)); end
end

module GraphQL::Testing::Helpers::SchemaHelpers
  include ::GraphQL::Testing::Helpers

  def run_graphql_field(field_path, object, arguments: T.unsafe(nil), context: T.unsafe(nil)); end
  def with_resolution_context(*args, **kwargs, &block); end

  class << self
    def for(schema_class); end
  end
end

class GraphQL::Testing::Helpers::TypeNotDefinedError < ::GraphQL::Testing::Helpers::Error
  def initialize(type_name:); end
end

class GraphQL::Testing::Helpers::TypeNotVisibleError < ::GraphQL::Testing::Helpers::Error
  def initialize(type_name:); end
end

module GraphQL::Tracing; end

module GraphQL::Tracing::ActiveSupportNotificationsTrace
  include ::GraphQL::Tracing::PlatformTrace
  include ::GraphQL::Tracing::NotificationsTrace

  def initialize(engine: T.unsafe(nil), **rest); end
end

module GraphQL::Tracing::ActiveSupportNotificationsTracing
  class << self
    def trace(key, metadata, &blk); end
  end
end

GraphQL::Tracing::ActiveSupportNotificationsTracing::KEYS = T.let(T.unsafe(nil), Hash)
GraphQL::Tracing::ActiveSupportNotificationsTracing::NOTIFICATIONS_ENGINE = T.let(T.unsafe(nil), GraphQL::Tracing::NotificationsTracing)

module GraphQL::Tracing::AppOpticsTrace
  include ::GraphQL::Tracing::PlatformTrace

  def analyze_multiplex(**data); end
  def analyze_query(**data); end
  def authorized(**data); end
  def authorized_lazy(**data); end
  def execute_field(query:, field:, ast_node:, arguments:, object:); end
  def execute_field_lazy(query:, field:, ast_node:, arguments:, object:); end
  def execute_multiplex(**data); end
  def execute_query(**data); end
  def execute_query_lazy(**data); end
  def lex(**data); end
  def parse(**data); end
  def platform_authorized_key(type); end
  def platform_field_key(field); end
  def platform_resolve_type_key(type); end
  def resolve_type(**data); end
  def resolve_type_lazy(**data); end
  def validate(**data); end

  private

  def gql_config; end
  def graphql_context(context, layer); end
  def graphql_multiplex(data); end
  def graphql_query(query); end
  def graphql_query_string(query_string); end
  def metadata(data, layer); end
  def multiplex_transaction_name(names); end
  def remove_comments(query); end
  def sanitize(query); end
  def span_name(key); end
  def transaction_name(query); end

  class << self
    def version; end
  end
end

GraphQL::Tracing::AppOpticsTrace::EXEC_KEYS = T.let(T.unsafe(nil), Array)

class GraphQL::Tracing::AppOpticsTrace::KeyCache
  include ::GraphQL::Tracing::PlatformTrace
  include ::GraphQL::Tracing::AppOpticsTrace
  include ::GraphQL::Tracing::PlatformTrace::BaseKeyCache
end

GraphQL::Tracing::AppOpticsTrace::PREP_KEYS = T.let(T.unsafe(nil), Array)

class GraphQL::Tracing::AppOpticsTracing < ::GraphQL::Tracing::PlatformTracing
  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, _key, data); end

  private

  def gql_config; end
  def graphql_context(context, layer); end
  def graphql_multiplex(data); end
  def graphql_query(query); end
  def graphql_query_string(query_string); end
  def metadata(data, layer); end
  def multiplex_transaction_name(names); end
  def remove_comments(query); end
  def sanitize(query); end
  def span_name(key); end
  def transaction_name(query); end

  class << self
    def version; end
  end
end

GraphQL::Tracing::AppOpticsTracing::EXEC_KEYS = T.let(T.unsafe(nil), Array)
GraphQL::Tracing::AppOpticsTracing::PREP_KEYS = T.let(T.unsafe(nil), Array)

module GraphQL::Tracing::AppsignalTrace
  include ::GraphQL::Tracing::PlatformTrace

  def initialize(set_action_name: T.unsafe(nil), **rest); end

  def analyze_multiplex(**data); end
  def analyze_query(**data); end
  def authorized(type:, query:, object:); end
  def authorized_lazy(type:, query:, object:); end
  def execute_field(query:, field:, ast_node:, arguments:, object:); end
  def execute_field_lazy(query:, field:, ast_node:, arguments:, object:); end
  def execute_multiplex(**data); end
  def execute_query(**data); end
  def execute_query_lazy(**data); end
  def lex(**data); end
  def parse(**data); end
  def platform_authorized(platform_key); end
  def platform_authorized_key(type); end
  def platform_execute_field(platform_key); end
  def platform_field_key(field); end
  def platform_resolve_type(platform_key); end
  def platform_resolve_type_key(type); end
  def resolve_type(query:, type:, object:); end
  def resolve_type_lazy(query:, type:, object:); end
  def validate(**data); end
end

class GraphQL::Tracing::AppsignalTrace::KeyCache
  include ::GraphQL::Tracing::PlatformTrace
  include ::GraphQL::Tracing::AppsignalTrace
  include ::GraphQL::Tracing::PlatformTrace::BaseKeyCache
end

class GraphQL::Tracing::AppsignalTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

module GraphQL::Tracing::CallLegacyTracers
  def analyze_multiplex(multiplex:); end
  def analyze_query(query:); end
  def authorized(query:, type:, object:); end
  def authorized_lazy(query:, type:, object:); end
  def execute_field(field:, query:, ast_node:, arguments:, object:); end
  def execute_field_lazy(field:, query:, ast_node:, arguments:, object:); end
  def execute_multiplex(multiplex:); end
  def execute_query(query:); end
  def execute_query_lazy(query:, multiplex:); end
  def lex(query_string:); end
  def parse(query_string:); end
  def resolve_type(query:, type:, object:); end
  def resolve_type_lazy(query:, type:, object:); end
  def validate(query:, validate:); end
end

module GraphQL::Tracing::DataDogTrace
  include ::GraphQL::Tracing::PlatformTrace

  def initialize(tracer: T.unsafe(nil), analytics_enabled: T.unsafe(nil), analytics_sample_rate: T.unsafe(nil), service: T.unsafe(nil), **rest); end

  def analyze_multiplex(**data); end
  def analyze_query(**data); end
  def authorized(query:, type:, object:); end
  def authorized_lazy(object:, type:, query:); end
  def authorized_span(span_key, object, type, query); end
  def execute_field(query:, field:, ast_node:, arguments:, object:); end
  def execute_field_lazy(query:, field:, ast_node:, arguments:, object:); end
  def execute_field_span(span_key, query, field, ast_node, arguments, object); end
  def execute_multiplex(**data); end
  def execute_query(**data); end
  def execute_query_lazy(**data); end
  def lex(**data); end
  def parse(**data); end
  def platform_authorized_key(type); end
  def platform_field_key(field); end
  def platform_resolve_type_key(type); end
  def resolve_type(object:, type:, query:); end
  def resolve_type_lazy(object:, type:, query:); end
  def resolve_type_span(span_key, object, type, query); end
  def validate(**data); end
end

class GraphQL::Tracing::DataDogTrace::KeyCache
  include ::GraphQL::Tracing::PlatformTrace
  include ::GraphQL::Tracing::DataDogTrace
  include ::GraphQL::Tracing::PlatformTrace::BaseKeyCache
end

class GraphQL::Tracing::DataDogTracing < ::GraphQL::Tracing::PlatformTracing
  def analytics_enabled?; end
  def analytics_sample_rate; end
  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
  def prepare_span(key, data, span); end
  def tracer; end
end

module GraphQL::Tracing::LegacyHooksTrace
  def execute_multiplex(multiplex:); end
end

module GraphQL::Tracing::LegacyHooksTrace::RunHooks
  private

  def call_after_hooks(instrumenters, object, after_hook_name, ex); end
  def call_hooks(instrumenters, object, before_hook_name, after_hook_name); end
  def each_query_call_hooks(instrumenters, queries, i = T.unsafe(nil)); end

  class << self
    def call_after_hooks(instrumenters, object, after_hook_name, ex); end
    def call_hooks(instrumenters, object, before_hook_name, after_hook_name); end
    def each_query_call_hooks(instrumenters, queries, i = T.unsafe(nil)); end
  end
end

class GraphQL::Tracing::LegacyTrace < ::GraphQL::Tracing::Trace
  include ::GraphQL::Tracing::CallLegacyTracers
end

module GraphQL::Tracing::NewRelicTrace
  def initialize(set_transaction_name: T.unsafe(nil), trace_authorized: T.unsafe(nil), trace_resolve_type: T.unsafe(nil), **_rest); end

  def begin_analyze_multiplex(multiplex, analyzers); end
  def begin_authorized(type, obj, ctx); end
  def begin_dataloader(dl); end
  def begin_dataloader_source(source); end
  def begin_execute_field(field, object, arguments, query); end
  def begin_execute_multiplex(multiplex); end
  def begin_parse(query_str); end
  def begin_resolve_type(type, value, context); end
  def begin_validate(query, validate); end
  def dataloader_fiber_resume(source); end
  def dataloader_fiber_yield(source); end
  def end_analyze_multiplex(multiplex, analyzers); end
  def end_authorized(type, obj, ctx, is_authed); end
  def end_dataloader(dl); end
  def end_dataloader_source(source); end
  def end_execute_field(field, objects, arguments, query, result); end
  def end_execute_multiplex(multiplex); end
  def end_parse(query_str); end
  def end_resolve_type(type, value, context, resolved_type); end
  def end_validate(query, validate, validation_errors); end

  private

  def fallback_transaction_name(context); end
  def nr_segment_stack; end
  def transaction_name(query); end
end

class GraphQL::Tracing::NewRelicTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

module GraphQL::Tracing::NotificationsTrace
  include ::GraphQL::Tracing::PlatformTrace

  def initialize(engine:, **rest); end

  def analyze_multiplex(**metadata, &block); end
  def analyze_query(**metadata, &block); end
  def authorized(**metadata, &block); end
  def authorized_lazy(**metadata, &block); end
  def execute_field(**metadata, &block); end
  def execute_field_lazy(**metadata, &block); end
  def execute_multiplex(**metadata, &block); end
  def execute_query(**metadata, &block); end
  def execute_query_lazy(**metadata, &block); end
  def lex(**metadata, &block); end
  def parse(**metadata, &block); end
  def resolve_type(**metadata, &block); end
  def resolve_type_lazy(**metadata, &block); end
  def validate(**metadata, &block); end
end

class GraphQL::Tracing::NotificationsTrace::KeyCache
  include ::GraphQL::Tracing::PlatformTrace
  include ::GraphQL::Tracing::NotificationsTrace
  include ::GraphQL::Tracing::PlatformTrace::BaseKeyCache
end

class GraphQL::Tracing::NotificationsTracing
  def initialize(notifications_engine); end

  def trace(key, metadata, &blk); end
end

GraphQL::Tracing::NotificationsTracing::KEYS = T.let(T.unsafe(nil), Hash)
GraphQL::Tracing::NotificationsTracing::MAX_KEYS_SIZE = T.let(T.unsafe(nil), Integer)
GraphQL::Tracing::NullTrace = T.let(T.unsafe(nil), GraphQL::Tracing::Trace)

module GraphQL::Tracing::NullTracer
  private

  def trace(k, v); end

  class << self
    def trace(k, v); end
  end
end

module GraphQL::Tracing::PerfettoTrace
  def initialize(active_support_notifications_pattern: T.unsafe(nil), **_rest); end

  def begin_analyze_multiplex(m, analyzers); end
  def begin_authorized(type, obj, ctx); end
  def begin_dataloader(dl); end
  def begin_dataloader_source(source); end
  def begin_execute_field(field, object, arguments, query); end
  def begin_execute_multiplex(m); end
  def begin_parse(str); end
  def begin_resolve_type(type, value, context); end
  def begin_validate(query, validate); end
  def dataloader_fiber_exit; end
  def dataloader_fiber_resume(source); end
  def dataloader_fiber_yield(source); end
  def dataloader_spawn_execution_fiber(jobs); end
  def dataloader_spawn_source_fiber(pending_sources); end
  def end_analyze_multiplex(m, analyzers); end
  def end_authorized(type, obj, ctx, is_authorized); end
  def end_dataloader(dl); end
  def end_dataloader_source(source); end
  def end_execute_field(field, object, arguments, query, app_result); end
  def end_execute_multiplex(m); end
  def end_parse(str); end
  def end_resolve_type(type, value, context, resolved_type); end
  def end_validate(query, validate, validation_errors); end
  def write(file:, debug_json: T.unsafe(nil)); end

  private

  def count_allocations; end
  def count_fibers(diff); end
  def count_fields; end
  def debug_annotation(iid, value_key, value); end
  def dup_with(message, attrs, delete_counters: T.unsafe(nil)); end
  def fiber_flow_stack; end
  def fid; end
  def new_interned_data; end
  def payload_to_debug(k, v, iid: T.unsafe(nil), intern_value: T.unsafe(nil)); end
  def subscribe_to_active_support_notifications(pattern); end
  def tid; end
  def trace_packet(event_attrs); end
  def track_descriptor_packet(parent_uuid, uuid, name, counter: T.unsafe(nil)); end
  def ts; end
  def unsubscribe_from_active_support_notifications; end

  class << self
    def included(_trace_class); end
  end
end

GraphQL::Tracing::PerfettoTrace::ACTIVE_SUPPORT_NOTIFICATIONS_CATEGORY_IIDS = T.let(T.unsafe(nil), Array)
GraphQL::Tracing::PerfettoTrace::AUTHORIZED_CATEGORY_IIDS = T.let(T.unsafe(nil), Array)
GraphQL::Tracing::PerfettoTrace::DATALOADER_CATEGORY_IIDS = T.let(T.unsafe(nil), Array)
GraphQL::Tracing::PerfettoTrace::DA_ARGUMENTS_IID = T.let(T.unsafe(nil), Integer)
GraphQL::Tracing::PerfettoTrace::DA_FETCH_KEYS_IID = T.let(T.unsafe(nil), Integer)
GraphQL::Tracing::PerfettoTrace::DA_OBJECT_IID = T.let(T.unsafe(nil), Integer)
GraphQL::Tracing::PerfettoTrace::DA_RESULT_IID = T.let(T.unsafe(nil), Integer)
GraphQL::Tracing::PerfettoTrace::DA_STR_VAL_NIL_IID = T.let(T.unsafe(nil), Integer)
GraphQL::Tracing::PerfettoTrace::FIELD_EXECUTE_CATEGORY_IIDS = T.let(T.unsafe(nil), Array)
GraphQL::Tracing::PerfettoTrace::PROTOBUF_AVAILABLE = T.let(T.unsafe(nil), FalseClass)
GraphQL::Tracing::PerfettoTrace::RESOLVE_TYPE_CATEGORY_IIDS = T.let(T.unsafe(nil), Array)

module GraphQL::Tracing::PlatformTrace
  def initialize(trace_scalars: T.unsafe(nil), **_options); end

  def platform_authorized_lazy(key, &block); end
  def platform_execute_field_lazy(*args, &block); end
  def platform_resolve_type_lazy(key, &block); end

  private

  def fallback_transaction_name(context); end
  def transaction_name(query); end

  class << self
    def included(child_class); end
  end
end

module GraphQL::Tracing::PlatformTrace::BaseKeyCache
  def initialize; end

  def platform_authorized_key_cache; end
  def platform_field_key_cache; end
  def platform_resolve_type_key_cache; end
end

class GraphQL::Tracing::PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  def trace(key, data); end

  private

  def cached_platform_key(ctx, key, trace_phase); end
  def fallback_transaction_name(context); end
  def options; end
  def transaction_name(query); end

  class << self
    def inherited(child_class); end
    def platform_keys; end
    def platform_keys=(_arg0); end
    def use(schema_defn, options = T.unsafe(nil)); end
  end
end

module GraphQL::Tracing::PrometheusTrace
  include ::GraphQL::Tracing::PlatformTrace

  def initialize(client: T.unsafe(nil), keys_whitelist: T.unsafe(nil), collector_type: T.unsafe(nil), **rest); end

  def analyze_multiplex(**data); end
  def analyze_query(**data); end
  def authorized(type:, query:, object:); end
  def authorized_lazy(type:, query:, object:); end
  def execute_field(query:, field:, ast_node:, arguments:, object:); end
  def execute_field_lazy(query:, field:, ast_node:, arguments:, object:); end
  def execute_multiplex(**data); end
  def execute_query(**data); end
  def execute_query_lazy(**data); end
  def lex(**data); end
  def parse(**data); end
  def platform_authorized(platform_key, &block); end
  def platform_authorized_key(type); end
  def platform_authorized_lazy(platform_key, &block); end
  def platform_execute_field(platform_key, &block); end
  def platform_execute_field_lazy(platform_key, &block); end
  def platform_field_key(field); end
  def platform_resolve_type(platform_key, &block); end
  def platform_resolve_type_key(type); end
  def platform_resolve_type_lazy(platform_key, &block); end
  def resolve_type(query:, type:, object:); end
  def resolve_type_lazy(query:, type:, object:); end
  def validate(**data); end

  private

  def instrument_prometheus_execution(platform_key, key, &block); end
end

class GraphQL::Tracing::PrometheusTrace::KeyCache
  include ::GraphQL::Tracing::PlatformTrace
  include ::GraphQL::Tracing::PrometheusTrace
  include ::GraphQL::Tracing::PlatformTrace::BaseKeyCache
end

class GraphQL::Tracing::PrometheusTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(opts = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, _data, &block); end

  private

  def instrument_execution(platform_key, key, &block); end
  def observe(platform_key, key, duration); end
end

GraphQL::Tracing::PrometheusTracing::DEFAULT_COLLECTOR_TYPE = T.let(T.unsafe(nil), String)
GraphQL::Tracing::PrometheusTracing::DEFAULT_WHITELIST = T.let(T.unsafe(nil), Array)

module GraphQL::Tracing::ScoutTrace
  include ::GraphQL::Tracing::PlatformTrace

  def initialize(set_transaction_name: T.unsafe(nil), **_rest); end

  def analyze_multiplex(**data); end
  def analyze_query(**data); end
  def authorized(type:, query:, object:); end
  def authorized_lazy(type:, query:, object:); end
  def execute_field(query:, field:, ast_node:, arguments:, object:); end
  def execute_field_lazy(query:, field:, ast_node:, arguments:, object:); end
  def execute_multiplex(**data); end
  def execute_query(**data); end
  def execute_query_lazy(**data); end
  def lex(**data); end
  def parse(**data); end
  def platform_authorized(platform_key, &block); end
  def platform_authorized_key(type); end
  def platform_execute_field(platform_key, &block); end
  def platform_field_key(field); end
  def platform_resolve_type(platform_key, &block); end
  def platform_resolve_type_key(type); end
  def resolve_type(query:, type:, object:); end
  def resolve_type_lazy(query:, type:, object:); end
  def validate(**data); end
end

GraphQL::Tracing::ScoutTrace::INSTRUMENT_OPTS = T.let(T.unsafe(nil), Hash)

class GraphQL::Tracing::ScoutTrace::KeyCache
  include ::GraphQL::Tracing::PlatformTrace
  include ::GraphQL::Tracing::ScoutTrace
  include ::GraphQL::Tracing::PlatformTrace::BaseKeyCache
end

class GraphQL::Tracing::ScoutTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

GraphQL::Tracing::ScoutTracing::INSTRUMENT_OPTS = T.let(T.unsafe(nil), Hash)

module GraphQL::Tracing::SentryTrace
  include ::GraphQL::Tracing::PlatformTrace

  def initialize(set_transaction_name: T.unsafe(nil), **_rest); end

  def analyze_multiplex(**data); end
  def analyze_query(**data); end
  def authorized(type:, query:, object:); end
  def authorized_lazy(type:, query:, object:); end
  def execute_field(query:, field:, ast_node:, arguments:, object:); end
  def execute_field_lazy(query:, field:, ast_node:, arguments:, object:); end
  def execute_multiplex(**data); end
  def execute_query(**data); end
  def execute_query_lazy(**data); end
  def lex(**data); end
  def parse(**data); end
  def platform_authorized(platform_key, &block); end
  def platform_authorized_key(type); end
  def platform_authorized_lazy(platform_key, &block); end
  def platform_execute_field(platform_key, &block); end
  def platform_execute_field_lazy(platform_key, &block); end
  def platform_field_key(field); end
  def platform_resolve_type(platform_key, &block); end
  def platform_resolve_type_key(type); end
  def platform_resolve_type_lazy(platform_key, &block); end
  def resolve_type(query:, type:, object:); end
  def resolve_type_lazy(query:, type:, object:); end
  def validate(**data); end

  private

  def instrument_sentry_execution(platform_key, trace_method, data = T.unsafe(nil), &block); end
  def operation_name(query); end
end

class GraphQL::Tracing::SentryTrace::KeyCache
  include ::GraphQL::Tracing::PlatformTrace
  include ::GraphQL::Tracing::SentryTrace
  include ::GraphQL::Tracing::PlatformTrace::BaseKeyCache
end

module GraphQL::Tracing::StatsdTrace
  include ::GraphQL::Tracing::PlatformTrace

  def initialize(statsd:, **rest); end

  def analyze_multiplex(**data); end
  def analyze_query(**data); end
  def authorized(type:, query:, object:); end
  def authorized_lazy(type:, query:, object:); end
  def execute_field(query:, field:, ast_node:, arguments:, object:); end
  def execute_field_lazy(query:, field:, ast_node:, arguments:, object:); end
  def execute_multiplex(**data); end
  def execute_query(**data); end
  def execute_query_lazy(**data); end
  def lex(**data); end
  def parse(**data); end
  def platform_authorized(key, &block); end
  def platform_authorized_key(type); end
  def platform_execute_field(platform_key, &block); end
  def platform_field_key(field); end
  def platform_resolve_type(key, &block); end
  def platform_resolve_type_key(type); end
  def resolve_type(query:, type:, object:); end
  def resolve_type_lazy(query:, type:, object:); end
  def validate(**data); end
end

class GraphQL::Tracing::StatsdTrace::KeyCache
  include ::GraphQL::Tracing::PlatformTrace
  include ::GraphQL::Tracing::StatsdTrace
  include ::GraphQL::Tracing::PlatformTrace::BaseKeyCache
end

class GraphQL::Tracing::StatsdTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(statsd:, **rest); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::Trace
  def initialize(multiplex: T.unsafe(nil), query: T.unsafe(nil), **_options); end

  def analyze_multiplex(multiplex:); end
  def analyze_query(query:); end
  def authorized(query:, type:, object:); end
  def authorized_lazy(query:, type:, object:); end
  def begin_analyze_multiplex(multiplex, analyzers); end
  def begin_authorized(type, object, context); end
  def begin_dataloader(dataloader); end
  def begin_dataloader_source(source); end
  def begin_execute_field(field, object, arguments, query); end
  def begin_execute_multiplex(multiplex); end
  def begin_parse(query_str); end
  def begin_resolve_type(type, value, context); end
  def begin_validate(query, validate); end
  def dataloader_fiber_exit; end
  def dataloader_fiber_resume(source); end
  def dataloader_fiber_yield(source); end
  def dataloader_spawn_execution_fiber(jobs); end
  def dataloader_spawn_source_fiber(pending_sources); end
  def end_analyze_multiplex(multiplex, analyzers); end
  def end_authorized(type, object, context, authorized_result); end
  def end_dataloader(dataloader); end
  def end_dataloader_source(source); end
  def end_execute_field(field, object, arguments, query, result); end
  def end_execute_multiplex(multiplex); end
  def end_parse(query_str); end
  def end_resolve_type(type, value, context, resolved_type); end
  def end_validate(query, validate, errors); end
  def execute_field(field:, query:, ast_node:, arguments:, object:); end
  def execute_field_lazy(field:, query:, ast_node:, arguments:, object:); end
  def execute_multiplex(multiplex:); end
  def execute_query(query:); end
  def execute_query_lazy(query:, multiplex:); end
  def lex(query_string:); end
  def parse(query_string:); end
  def resolve_type(query:, type:, object:); end
  def resolve_type_lazy(query:, type:, object:); end
  def validate(query:, validate:); end
end

module GraphQL::Tracing::Traceable
  def trace(key, metadata, &block); end

  private

  def call_tracers(idx, key, metadata, &block); end
end

module GraphQL::TypeKinds; end
GraphQL::TypeKinds::ENUM = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::INPUT_OBJECT = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::INTERFACE = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::LIST = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::NON_NULL = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::OBJECT = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::SCALAR = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::TYPE_KINDS = T.let(T.unsafe(nil), Array)

class GraphQL::TypeKinds::TypeKind
  def initialize(name, abstract: T.unsafe(nil), leaf: T.unsafe(nil), fields: T.unsafe(nil), wraps: T.unsafe(nil), input: T.unsafe(nil), description: T.unsafe(nil)); end

  def abstract?; end
  def composite?; end
  def description; end
  def enum?; end
  def fields?; end
  def input?; end
  def input_object?; end
  def interface?; end
  def leaf?; end
  def list?; end
  def name; end
  def non_null?; end
  def object?; end
  def resolves?; end
  def scalar?; end
  def to_s; end
  def union?; end
  def wraps?; end
end

GraphQL::TypeKinds::UNION = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)

module GraphQL::Types
  extend ::GraphQL::Autoload
end

class GraphQL::Types::BigInt < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
    def parse_int(value); end
  end
end

class GraphQL::Types::Boolean < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

class GraphQL::Types::Float < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

class GraphQL::Types::ID < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

class GraphQL::Types::ISO8601Date < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, ctx); end
    def coerce_result(value, _ctx); end
  end
end

class GraphQL::Types::ISO8601DateTime < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(str_value, _ctx); end
    def coerce_result(value, _ctx); end
    def time_precision; end
    def time_precision=(value); end
  end
end

GraphQL::Types::ISO8601DateTime::DEFAULT_TIME_PRECISION = T.let(T.unsafe(nil), Integer)

class GraphQL::Types::ISO8601Duration < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, ctx); end
    def coerce_result(value, _ctx); end
    def seconds_precision; end
    def seconds_precision=(value); end
  end
end

class GraphQL::Types::Int < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, ctx); end
    def coerce_result(value, ctx); end
  end
end

GraphQL::Types::Int::MAX = T.let(T.unsafe(nil), Integer)
GraphQL::Types::Int::MIN = T.let(T.unsafe(nil), Integer)

class GraphQL::Types::JSON < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _context); end
    def coerce_result(value, _context); end
  end
end

module GraphQL::Types::Relay; end

class GraphQL::Types::Relay::BaseConnection < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::ConnectionBehaviors
  extend ::GraphQL::Schema::Member::HasInterfaces::ClassConfigured::InheritedInterfaces
  extend ::GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
end

class GraphQL::Types::Relay::BaseEdge < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::EdgeBehaviors
  extend ::GraphQL::Schema::Member::HasInterfaces::ClassConfigured::InheritedInterfaces
  extend ::GraphQL::Types::Relay::EdgeBehaviors::ClassMethods
end

module GraphQL::Types::Relay::ClassMethods
  def default_broadcastable?; end
  def default_relay?; end
end

module GraphQL::Types::Relay::ConnectionBehaviors
  extend ::Forwardable

  mixes_in_class_methods ::GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods

  def cursor_from_node(*args, **_arg1, &block); end
  def edges; end
  def nodes; end
  def parent(*args, **_arg1, &block); end

  class << self
    def add_page_info_field(obj_type); end
    def included(child_class); end
  end
end

module GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
  def authorized?(obj, ctx); end
  def default_broadcastable(new_value); end
  def default_broadcastable?; end
  def default_relay?; end
  def edge_class; end
  def edge_nullable(new_value = T.unsafe(nil)); end
  def edge_type(edge_type_class, edge_class: T.unsafe(nil), node_type: T.unsafe(nil), nodes_field: T.unsafe(nil), node_nullable: T.unsafe(nil), edges_nullable: T.unsafe(nil), edge_nullable: T.unsafe(nil), field_options: T.unsafe(nil)); end
  def edges_nullable(new_value = T.unsafe(nil)); end
  def has_nodes_field(new_value = T.unsafe(nil)); end
  def inherited(child_class); end
  def node_nullable(new_value = T.unsafe(nil)); end
  def node_type; end
  def nodes_field(node_nullable: T.unsafe(nil), field_options: T.unsafe(nil)); end
  def reauthorize_scoped_objects(new_value = T.unsafe(nil)); end
  def scope_items(items, context); end
  def visible?(ctx); end

  protected

  def edge_class=(_arg0); end
  def edge_type=(_arg0); end
  def node_type=(_arg0); end

  private

  def define_nodes_field(nullable, field_options: T.unsafe(nil)); end
end

module GraphQL::Types::Relay::EdgeBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::EdgeBehaviors::ClassMethods

  def node; end

  class << self
    def included(child_class); end
  end
end

module GraphQL::Types::Relay::EdgeBehaviors::ClassMethods
  def authorized?(obj, ctx); end
  def default_broadcastable(new_value); end
  def default_broadcastable?; end
  def default_relay?; end
  def inherited(child_class); end
  def node_nullable(new_value = T.unsafe(nil)); end
  def node_type(node_type = T.unsafe(nil), null: T.unsafe(nil), field_options: T.unsafe(nil)); end
  def visible?(ctx); end

  protected

  def node_nullable=(_arg0); end
  def node_type=(_arg0); end
end

module GraphQL::Types::Relay::HasNodeField
  class << self
    def field_block; end
    def field_options; end
    def included(child_class); end
  end
end

module GraphQL::Types::Relay::HasNodesField
  class << self
    def field_block; end
    def field_options; end
    def included(child_class); end
  end
end

module GraphQL::Types::Relay::Node
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Types::Relay::NodeBehaviors
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasFields::InterfaceMethods
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::HasDataloader
  extend ::GraphQL::Schema::Member::HasDirectives
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Types::Relay::NodeBehaviors::ClassMethods
end

class GraphQL::Types::Relay::Node::UnresolvedTypeError < ::GraphQL::UnresolvedTypeError; end

module GraphQL::Types::Relay::NodeBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::NodeBehaviors::ClassMethods

  def default_global_id; end

  class << self
    def included(child_module); end
  end
end

module GraphQL::Types::Relay::NodeBehaviors::ClassMethods
  def default_relay?; end
end

class GraphQL::Types::Relay::PageInfo < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::PageInfoBehaviors
  extend ::GraphQL::Schema::Member::HasInterfaces::ClassConfigured::InheritedInterfaces
  extend ::GraphQL::Types::Relay::ClassMethods
end

module GraphQL::Types::Relay::PageInfoBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::ClassMethods

  class << self
    def included(child_class); end
  end
end

class GraphQL::Types::String < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, ctx); end
  end
end

class GraphQL::UnauthorizedEnumValueError < ::GraphQL::UnauthorizedError
  def initialize(type:, context:, enum_value:); end

  def enum_value; end
  def enum_value=(_arg0); end
end

class GraphQL::UnauthorizedError < ::GraphQL::Error
  def initialize(message = T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil)); end

  def context; end
  def context=(_arg0); end
  def object; end
  def type; end
end

class GraphQL::UnauthorizedFieldError < ::GraphQL::UnauthorizedError
  def initialize(message = T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil), field: T.unsafe(nil)); end

  def field; end
  def field=(_arg0); end
end

class GraphQL::UnresolvedTypeError < ::GraphQL::RuntimeTypeError
  def initialize(value, field, parent_type, resolved_type, possible_types); end

  def field; end
  def parent_type; end
  def possible_types; end
  def resolved_type; end
  def value; end
end

GraphQL::VERSION = T.let(T.unsafe(nil), String)
